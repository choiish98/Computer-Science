# 운영체제

* [1. 개요](#1-개요)
  * 컴퓨터 시스템 개요
  * 운영체제 개요
* [2. 프로세스](#2-프로세스)
* [3. 쓰레드](#3-쓰레드)
* [4. 병행성](#4-병행성)
* [5. 메모리](#5-메모리)
  * 메모리 관리
  * 가상 메모리
* [6. 스케쥴링](#6-스케쥴링)
  * 단일처리기 스케쥴링
  * 멀티 프로세서, 멀티 코어 및 
* [7. 입출력과 파일](#7-입출력과-파일)
  * 입출력 파일과 디스크 스케쥴링
  * 파일 관리

<br>

---
## 1. 개요

### (1) 컴퓨터 시스템 개요

- 목적: 운영체제는 하나 이상의 처리기로 구성된 하드웨어 자원을 활용하여 시스템 사용자에게 다양한 서비스를 제공한다. 또한 운영체제는 사용자 관점에서 보조기억장치와 입출력 장치를 관리한다. 따라서 운영체제를 살펴보기 전에 그 기반이 되는 컴퓨터 시스템 하드웨어를 어느 정도 이해하는 것이 중요하다.



- 기본 구성 요소
  - **처리기(프로세서, processor)**: 컴퓨터의 동작을 제어하고 데이털르 처리한다. 처리기가 하나만 있는 경우에는 일반적으로 중앙처리장치(CPU)라고 한다.
  - **주기억장치(main  memory)**: 데이터와 프로그램을 저장한다. 전형적으로 휘발성이기 때문에, 컴퓨터가 셧다운 될 경우 메모리의 내용이 없어지게 된다. 대조적으로, 디스크 메모리의 내용은 컴퓨터가 셧다운되더라도 유지된다. 주기억장치는 실기억장치 혹은 주메모리라고도 불린다.
  - **입출력 모듈(I/O module)**: 컴퓨터와 외부 환경 간의 데이터 이동을 담당한다. 외부 환경은 보조기억장치, 통신장비, 그리고 단말기를 포함한 다양한 외부 장치로 구성된다.
  - **시스템 버스(System bus)**: 처리기, 주기억장치, 그리고 입출력 모듈간의 통신을 제공한다.



- 명령어 수행: 단일 명령어 수행에 필요한 처리 과정을 명령어 사이클이라고 한다. 단순화된 2-단계 설명ㅇ을 사용하여 명령어 사이클을 나타내면 반입단계와 수행 단계로 나타낸다.

  ![프로그램 수행의 예](https://user-images.githubusercontent.com/56579239/152929423-4f8f1246-b29b-442c-aad3-c9f6b97a75d1.png)


  *메모리와 레지스터의 프로그램 명령어 수행의 예*



- 인터럽트: 가상적으로 모든 컴퓨터는 처리기의 일반적인 처리에 다른 모듈들이 인터럽트를 걸 수 있도록 허용하고 있다. 인터럽트는 기본적으로 처리기의 처리율을 향상시키기 위해 제공된다. 예를 들어 대부분의 입출력 장치들은 처리기에 비해 훨씬 느리다. 명령어 사이클 기법을 사용하여 처리기가 프린터로 데이터를 전송한다고 가정하자. 매번 쓰기 연산 이후, 처리기는 수행을 일시 중단하고 프린터가 출력을 완료할 때까지 유휴상태가 된다. 이러한 중단 시간은 수백 또는 수천 개의 처리기 명령어 사이클을 낭비하게 된다.

  ![인터럽트 예시](https://user-images.githubusercontent.com/56579239/152929400-e1e6ab65-7c5f-4646-9501-d41b570afdd3.png)


  *인터럽트 예시*



- 메모리 계층 구조: 메모리 관련 세 가지 주요 특성인 **용량**, **접근속도** 그리고 **비용** 간에는 상호 절충 관계가 있다.

  - 접근 시간이 짧을 수록 비트당 비용이 높아짐
  - 용량이 클수록 비트당 비용이 낮아짐
  - 용량이 클수록 접근 시간이 길어짐

  이러한 딜레마를 벗어나기 위해 단일 메모리 요소나 기술에 의존하지 않고 메모리 계층 구조를 채택하여 사용한다. 크고 저렴하고 속도가 느린 메모리가 작고 비싸고 빠른 메모리를 보완한다. 이런 구성의 성공 열쇠는 저속의 메모리에 대한 접근 회수를 줄이는 것이다. (캐시, 참조지역성)

  ![메모리 계층 구조 예](https://user-images.githubusercontent.com/56579239/152929379-73b9ae1b-d749-4fd9-a6a4-9acfa60ebfb6.png)


  *메모리 계층 구조*



- 캐시 메모리: 처리기의 명령어 수행 속도는 명령어 사이클 시간에 의해 제약을 받는다. 이러한 제약은 처리기와 주기억장치 속도 차이로 인해 심각한 문제가 된다. 이상적으로는 메모리 사이클 시간과 처리기 사이클 시간이 비슷하도록 주기억장치도 처리기 레지스터가 채택한 것과 동일한 기술을 이용하여 구축되어야 한다. 그러나 이런한 전략을 채택하는 것은 항상 너무 많은 비용이 든다. 해결책은 처리기와 메모리 간에 캐시와 같은 용량은 적으나 빠른 메모리를 제공함으로써 지역성의 원리를 이용하는 것이다.

  비교적 대용량이고 속도가 느린 주기억장치가 소용량이지만 속도가 빠른 캐시와 함께 사용된다. 캐시는 주기억장치 일부의 복사본을 포함하고있다. 처리기가 메모리에서 한 워드를 읽으려 할 때, 그 워드가 캐시 내에 있는지 여부를 점검해야 한다. 만약 그렇다면 그 워드는 처리기로 전달된다. 그 워드가 캐시 내에 존재하지 않으면, 약간의 고정된 개수의 워드로 구성된 주기억장치 블록이 캐시로 읽혀진 뒤, 해당 워드가 처리기로 전달된다. **참조 지역성** 때문에, 어떤 메모리의 참조를 위해 ㅏ나의 데이터 블록을 캐시로 가져오게 되면, 그 이후의 참조는 그 블록내에 있는 한 워드가 될 확률이 높다.

  ![캐시 메모리 예](https://user-images.githubusercontent.com/56579239/152929366-cbf6a7ab-55b3-49f9-9038-0bc8d516ef66.png)


  *캐시 메모리 예*



- 직접 메모리 접근(DMA): 대량의 데이터가 이동되어야 할 때, 직접 메모리 접근과 같은 효율적인 기술이 요구된다. DMA 모듈은 프로세서를 거치지 않고 데이터 블록 전체를 한 번에 한 워드씩 메모리로부터 또는 메모리로 전송한다. 전반적으로 볼 때 DMA 전송 동안 프로세서의 수행이 조금 느려지게 된다. 그럼에도 불구하고 다수의 워드에 대한 I/O 전송의 경우 DMA가 인터럽트 구동이나 프로그램된 입출력에 비해 훨씬 효과적이다.



- 멀티 프로세서와 멀티 코어

  - **SMP**: SMP는 컴퓨터 하드웨어 구조나 그 구조를 활용하는 운영체제의 행동 양식을 일컫는다. SMP는 달이처리기 구조에 비해 아래와 같은 일련의 잠재적 장점들을 가진다.

    - 성능: 컴퓨터가 수행해야 할 작업의 일부가 병렬로 처리될 수 있다면, 여러 개의 처리기로 구성된 시스템은 동일한 타입의 단일 처리기로 구성된 시스템에 비해 많은 성능 향상이 가능하다.
    - 가용성: 대칭형 멀티 프로세서 시스템에서 모든 처리기들이 동일한 기능을 수행할 수 있기 때문에, 하나의 처리기가 고장나더라도 시스템은 다소 성능이 떨어진 상태에서 지속적으로 동작할 수 있다.
    - 점진적 확장: 사용자는 성능 향상을 위해 필요할 때마다 처리기를 추가로 설치할 수 있다.
    - 크기 조저이 벤더들은 시스템을 구성하는 처리기의 수에 따라 가격과 성능이 다른 다양한 제품을 공급할 수 있다.

    ![대칭형 멀티 프로세서](https://user-images.githubusercontent.com/56579239/152929301-7ec0f260-1064-4b08-a079-cbb2f7fe2fd0.png)
아그램.png)

    *대칭형 멀티 프로세서 구조*

    

  - **멀티코어 컴퓨터**: 하드웨어의 발전, 클럭 주파수의 증가와 멀티 컴퓨터의 구성 요소를 점차 소형할 수 있는 능력이 프로세서에 캐시를 보다 가깝게 놓을 수 있도록 만들었다. 명령어 실행과 메모리 접근의 병렬화를 이용함에 따라 성능도 프로세서 디자인의 복잡도가 증가함에 따라 증가되었다. 설계자들은 하드웨어 고급화의 이점으로 성능을 증가시킬 수 있는 최고의 방법으로 다중 프로세서와 상당한 양의 캐시 메모리를 단일 칩에 넣는 것임을 발견했다.

    ![멀티 코어 블럭 다이아그램](https://user-images.githubusercontent.com/56579239/152929354-0342fe9d-c03b-427c-80dc-fdc7b26b1d9a.png)


    *멀티 코어 블럭 다이어그램*
    
## 2. 프로세스
## 3. 쓰레드
## 4. 병행성
## 5. 메모리
## 6. 스케쥴링
## 7. 입출력과 파일
