### (2) 네트워크 모델

#### (1) 계층 구조의 개념

`네트워크에 연결된 시스템이 통신하려면 정해진 규칙`에 따라 데이터를 주고 받아야 하는데, 이러한 규칙을 **프로토콜**이라 한다. 
프로토콜의 동작 과정은 전송 오류율, 데이터 전달 경로, 전달 속도 등 다양한 외부 요인의 영향을 받는다. 
따라서 적절한 대응 방안을 마련해 효율적으로 관리해야 하는데, 프로토콜의 설계 과정은 모듈화를 통하여 이루어진다. 
이렇게 함으로써 사용자에게 더 편리하고 간편한 통신 기능을 제공할 수 있다.

##### (1) 계층적 모듈 구조

일반적으로 복잡하고 큰 시스템의 기능은 특정 단위의 모듈로 나누어 설계한다. 
모듈은 독립적으로 동적하면서도 상호 유기적으로 통합될 수 있어야 한다. 
그러므로 모듈 사이에는 적절한 인터페이스가 필요하다.

###### (1) 모듈화
복잡한 시스템을 기능별로 모듈화 하면 시스템 구조가 단순해져서 전체 시스템을 이해하기 쉽다. 
또한 각 단위 모듈이 독립적인 기능을 수행하기 때문에 고장이나 업그레이드 등의 상황에 손쉽게 대처할 수 있다.

소프트웨어 측면에서 보면, 함수 별로 특정 기능을 독립적으로 수행함으로써 각 함수가 개별적으로 설계되고 구현된다는 장점이 있다. 
함수 사이의 인터페이스는 함수의 매개변수에 의해서만 이루어지고 전체 시스템을 이해하기가 훨씬 쉽다.

###### (2) 계층 구조
분할 모듈들은 협력 관계를 유지하면서 유기적으로 동작한다. 
대부분의 모듈 구조에서는 특정 모듈이 다른 모듈에 서비스를 제공하는 형식의 계층 구조를 이룬다. 
네트워크에서도 독립적인 고유 기능을 수행하는 모듈들이 상하위의 계층 구조로 연결되어 동작한다.

계층 구조에서는 상위 계층이 하위 계층에 특정 서비스를 요청하는 방식으로 동작한다. 
요청을 받은 하위 계층은 해당 서비스를 실행하여 그 결과를 상위 계층에 골려준다. 
자동차를 예를 들면, 운전자가 자동차의 속도를 줄이려면 브레이크를 밟아야 한다. 
여기서 운전자는 상위 계층이고 자동차의 브레이크 기능은 하위 계층이다. 
그리고 두 모듈은 브레이크라는 인터페이스에 의해 통신한다.

모듈화된 계층 구조 프로토콜은 다음과 같은 장점이 있다.
- 복잡하고 큰 시스템을 기능별로 작게 분류해서 간단하고 작은 시스템으로 재구성 할 수 있다. 
따라서 `시스템을 이해하기 쉽고, 시스템을 설계하고 구현하기도 편리`하다.
- 상하 계층에 인접한 모듈 사이의 인터페이스를 포함하여 분할된 모듈이 연동할 수 있는 표준 인터페이스를 제공한다. 
모듈 인터페이스는 가능한 가장 단순하게 구현되어 **모듈의 독립성**을 보장한다. 
모듈의 독립성은 `전체 시스템의 구조를 단순하게 만들어준다.`
- 전송 매체 양단에 있는 호스트가 수행하는 프로토콜들은 **좌우 대칭 구도**이다.
대칭 구조에서는 통신 양단에 위치하는 `동알 계층 사이의 프로토콜을 단순`하게 만들어준다.
- `각 계층의 기능 오류를 수정하거나 향상시켜야 하는 경우에 전체 시스템을 재작성하지 않고 해당 계층의 모듈만 교체하면 된다.` 
즉, 인터페이스를 유지하면 특정 계층의 내부 변경이 다른 모듈의 동작에 영향을 미치지 않는다.

##### (2) 프로토콜 설계 시 고려사항
계층 구조의 통신 프로토콜을 설계할 때는 네트워크의 주소 표현 방법, 데이터 전송 과정에서의 오류 제어, 통신 양단 사이의 전송 속도를 제어하는 흐름 제어 등 여러 가지 요소를 고려해야 한다.
주소 표현은 호스트를 유일하게 구분하는 용도로 사용한다. 오류 제어는 전송 과정에서의 오류가 발생했을 때 데이터를 복구하는 데 사용한다. 흐름 제어는 송신자가 데이터를 너무 빨리 보내어 수신자가 미처 처리하지 못 하는 문제를 해결하기 위해 사용한다.

###### (1) 주소 표현
여러 호스트가 연결된 환경에서 특정 호스트끼리 통신하려면 상대방을 구분할 수 있는 방법이 필요하다. 
`시스템을 구분하여 지칭하기 위해서 이름을 부여하는 것`을 **주소 체계**라고 한다. 
주소 체계는 시스템 설계 과정에서 맨 먼저 고려해야하는 중요한 개념이다.

###### (2) 오류 제어
네트워크에서는 데이터 송수신 과정에서 오류가 발생할 수 있다.
전송 오류에는 데이터가 깨져서 도착하는 데이터 변형 오류와 데이터가 도착하지 못 하은 데이터 분실 오류가 있다. 
전송 오류 문제를 해결하는 오류 제어 기능은 통신 프로토콜의 가장 기본적인 기능에 속한다. 

오류가 발생하는 1차 원인은 물리 계층의 전송 매체에 의한 물리적인 오류이다.
이를 해결하기 위해 데이터 링크 계층이 물리적인 전송 오류를 해결한다. 
그리고 상위 계층의 프로토콜이 수행될 때는 논리적인 전송 오류가 발생할 수 있으므로 상위 계층에서도 전송 오류 문제를 다룬다.

###### (3) 흐름 제어
전송 매체에서 물리적인 오류가 없었는데도 데이터를 분실하는 경우가 있는데, 이는 송수신 호스트 사이의 데이터 전송/처리의 속도 차이 때문에 발생하기도 한다. 
수신 호스트가 데이터가 도착하면 일단 내부 버퍼에 보관했다가 처리한다. 
그런데 내부 버퍼에 보관할 공간을 확보하지 못 하면 데이터를 논리적으로 분실하는 결과를 초래한다.

일반적으로 수신 호스트의 버퍼 처리 속도보다 송신 호스트가 데이터를 전송하는 속도가 빠르면 논리적인 데이터 분실 오류가 발생할 수 있다. 
이 문제를 해결하려면 `송신 호스트의 전송 속도를 조절`하는 **흐름 제어** 기능이 필요하다.

흐름 제어 기법은 다음과 같이 이루어진다.
송신 호스트가 데이터를 보내고 수신 호스트가 이를 제대로 받는다. 
이후 수신 호스트가 수신할 여력이 있을 경우에만 다음 데이터 전송 허가를 보낸다. 
송신 호스트는 전송 허가를 수신한 후 데이터를 전송한다. 이와 같은 흐름 제어 기능은 보통 수신 호스트에 의해 이루어진다.

###### (4) 데이터 전달 방식
프로토콜 설계 시 고려할 마지막 사항은 데이터 전달 방식이다.
`일대일 통신 환경에서 한 쪽으로만 전송하는 것`을 **단방향 방식**이라 하고, `양쪽에서 데이터를 동시에 전송하는 것을` **전이중 방식**이라 한다. 
`데이터가 양방향으로 전송되지만 특정 시잠에는 한 쪽 방향으로만 전송할 수 있는 방식`을 **반이중 방식**이라 한다. 

##### (3) 서비스 프리미티브
프로토콜은 계층 구조로 이루어져 있고, 하위 계층이 상위 계층에 서비스를 제공하는 방식으로 동작한다. 
이러한 서비스는 **프리미티브** 형태로 구현된다. 
계층 구조 프로토콜에서 하위 계층이 상위 계층에 제공하는 서비스의 종류에는 연결형과 비연결형이 있다.

- **연결형 서비스**: 연결형 서비스를 이용하는 절차는 크게 3단계다. 
먼저 데이터 전달 경로를 설정하는 연결 설정 단계가 필요하다.
이후 게이터를 전송하는 단계가 수행된다. 
데이터의 전송이 완료되면 연결을 끊은 연결 해제 단계가 필요하다.
연결형 서비스의 동작 원리은 전화 시스템과 비슷하다
- **비연결형 서비스**: 비연결형 서비스은 우편 시스템의 동작 원리와 비슷하다. 
전송할 데이터가 있으면 각 데이터를 독립적으로 목적지 호스트로 전송하면 된다.
데이터는 독립적인 경로 선택 과정에 의해 전달되므로 도착하는 순서가 보낸 순서와 일치하지 않을 수 있다.

하위 계층이 상위 계층에 제공하는 서비스는 프리미티브 형태로 구현된다. 
따라서 프리미티브는 하위 계층을 사용하는 방법을 정형화 한 것이다.

![2-1 서비스 프리미티브의 동작 원리](https://user-images.githubusercontent.com/56579239/157850729-1e4f89c0-da3c-44e0-8e44-797364900734.jpg)

통신 프로토콜에서 프리미티브를 올바르게 수행하려면 각 프리미티브를 네 가지 기능을 포함하도록 설계해야 한다.
- **Request**: 클라이언트에서 발생하며, 서버가 프리미티브의 기능을 수행하도록 하위 프로토콜에 요청할 때 사용한다.
- **Indication**: 클라이언트로부터 Request 요청을 수신한 서버의 하위 프로토콜은 Indication을 사용해서 프리미티브 요청이 발생했음을 알린다.
- **Response**: 클라이언트로부터 프리미티브를 받은 서버에서는 Response를 이용해 클라이언트에 응답한다.
- **Confirm**: 서버에서 보낸 응답은 Confirm 형태로 클라이언트에 회신된다.

#### (2) OSI 참조 모델
네트워크에 연결된 컴퓨터들이 데이터를 주고 받으면서도 서로 연동할 수 있게 표준화된 인터페이스를 지원해야 한다. 일반적으로 컴퓨터 네트워크에서는 모듈화된 프로토콜 스택을 사용한다.
국제 표준화 기구인 ISO가 확립한 **OSI 7계층** 모델은 개방화된 데이터 통신 환경에 적합한 계층적 구현 모델의 표준이다.

##### (1) OSI 7계층 모델

![2-2  OSI 7계층 모델의 동작](https://user-images.githubusercontent.com/56579239/157850800-be30f37a-a6cd-440a-99c1-96339b35781a.jpg)

다음은 ISO에서 제시한 OSI 7계층 모델이다. 연결된 두 호스트가 각각 7계층으로 구성된 모듈을 수행함으로써 데이터 송수신이 가능하다.
전송 데이터는 송신 호스트의 응용 계층에서 시작해 하위 계층으로 순차적으로 전달되어, 최종적으로 물리 계층에서 수신 호스트에 전달된다.
수신 호스트에서는 데이터를 순차적으로 상위 계층으로 이동시켜 응용 계층까지 보내준다.

###### (1) 용어 정의
`임의의 호스트에서 실행되는 계층 n 모듈은 상대 호스트의 계층 n 모듈과 논리적으로 통신하는데, 이들이 사용하는 규칙`을 **n 프로토콜**이라 한다.
프로토콜의 역할은 프로토콜에서 정의된 기능을 수행하면서 필요한 정보를 서로 교환하는 것이다.
프로토콜의 기능을 원활하게 수행하려면 주소 표현 방법, 오류 제어, 흐름 제어 등의 기능이 설계와 구현 과정에서 반영되어야 한다.

`동일 계층에 위치한 통신 양단`은 같은 프로토콜을 사용하여 통신하기 때문에 **동료 프로세스**라 한다.
한 호스트에서 상하로 이웃하는 계층에 위치한 모듈 사이에는 인터페이스가 정의되어 둘 사이의 접근 방법을 제한한다.
상위 계층에서는 하위 계층의 인터페이스를 통해 하위 계층의 서비스를 이용할 수 있다.

송신 호스트에서 데이털르 전달할 때는 동료 프로세스에 직접 전달하는 것이 아니라, 하위 계층을 통하여 간접적으로 서비스를 요청한다.
이 요청은 최하위에 있는 물리 계층까지 반복된다.
수신 호스트에서는 반대로 상위 계층으로 데이터가 전달되면서 프로토콜 기능이 동작한다.
각 계층의 동료 프로세스가 직접 통신하는 형태를 보이지만, 실제로는 항상 물리 계층을 통해 데이터가 전송되는 것이다.

###### (2) 헤더 정보
프로토콜 스택의 맨위에 위치한 일반 사용자는 전송 데이터가 있으면 이를 응용 계층에 보내 전송을 요청한다. 
응용 계층에서는 `데이터에 자신의 프로토콜에서 정의한 헤더 정보를 추가해 표현 계층에 보낸다.`
이런 일련의 과정은 물리 계층에서 데치터가 물리적으로 전송될 때까지 반복된다.

물리 계층에서는 수신 호스트에 실제로 데이터를 전송하고, 이를 수신한 호스트에서는 송신 절차와 반대 방향으로 헤더를 제거하는 과정이 반복된다.
즉, `계층 별로 해당 계층의 헤더 정보를 해석하여 적절히 처리한 후에 상위 계층으로 올려준다.`
송신 호스트에서 계층별로 추가된 헤더 정보가 수신 호스트에서 해석 및 삭제되어 최상위 수신자는 원래의 전송 데이터를 받는다.
각 계층의 프로토콜은 정해진 기능을 수행하여 데이터 송신 과정에서 발생하는 무네점을 해결해준다.

###### (3) 중개 기능
송신 호스트에서 수신 호스트로 데이터를 전달하려면 중개 역할을 수행하는 중개 노드를 거쳐야 한다.
중개 시스템은 데이터가 목적지까지 올바르게 전달되도록 경로 배정 기능을 수행한다.
중개 시스템에서는 `경로 배정 기능을 수행하는 네트워크 계층의 프로토콜`이 동작하는데, 이와 같은 경로 배정 기능을 **라우팅**이라 한다.

중개 노드인 라우터는 자신에게 도착한 데이터의 헤더 정보를 해석해서 적절한 경로로 전달하며, 다음 라우터로 보내기 전에 헤더 정보를 수정하는 작업도 진행한다.
라우터 좌우에 위치한 네트워크가 다르면 물리적인 특성 뿐 아니라 하위 계층의 헤더 정보도 다를 수 있다.
따라서 헤더 정보 값을 해석하여 변환하는 작업은 라우터의 주요 기능에 해당한다.

##### (2) 계층별 기능
OSU 7계층 모델의 모든 계층이 중요하지만, 특히 전송 계층이 중요하다. 전송 계층은 통신 양단에 있는 최종 사용자 사이의 종단 연결을 제공한다.
호스트에서 실행되는 프로세스와 프로세스 사이의 연결을 설정하여 데이터를 주고 받을 수 있게 해주는 것이 전송 계층이다.
전화 시스템을 예로 들면, 통화자 사이에 통화 연결을 설정하는 것이 바로 전송 계층이다.

전송 계층의 하위에 있는 물리 계층, 데이터 링크 계층, 네트워크 계층은 전송 계층의 연결을 설정하고 지원하는 역할을 수행한다.
상위에 있는 세션 계층, 표현 계층, 응용 계층은 전송 계층의 연결을 어떻게 활용할 지에 대하여 다룬다.
따라서 OSI 7계층 모델은 전송 계층을 기준으로 두 부분으로 나뉜다고 볼 수 있다.
실제로 TCP/IP 모델에서는 운영체제 내부에 계층 4까지의 기능을 구현하고, 상위 계층의 기능은 사용자 프로그램으로 구현한다.

###### (1) 물리 계층
OSI 7계층 모델의 맨 밑에 위치하는 **물리 계층**은 전송 매체의 물리적 인터페이스에 관한 사항을 기술한다.
즉, 전송 매체에서는 `개별 정보의 비트 교환 문제를 다룬다.`
물리 계층은 하드웨어 시스템으로 구현되고, 계층 2 이상의 프로토콜들은 소프트웨어적으로 구현된다.

###### (2) 데이터 링크 계층
**데이터 링크 계층**은 물리 계층을 통해 `전송되는 데이터의 물리적 전송 오류를 해결`한다.
결과적으로 상위의 네트워크 계층에 신뢰성 있는 패킷 전송을 보장해주어 전송 오류에 대한 부담을 없애준다.
데이터 링크 계층은 갈림길에서 전송 경로를 선택할 수 없으므로 두 호스트가 일대일로 직접 연결된 환경에서만 데이터 전송을 지원한다.
`데이터 링크 계층을 이용해 전송되는 데이터`를 **프레임**이라 부른다. 프레임 헤더에 표시되는 송수신 호스트 정보에는 LAN 카드에 내장된 송수신 호스트의 MAC 주소가 기록된다.
데이터 링크 계층은 다른 상위 계층처럼 송신 호스트와 수신 호스트 사이의 전송 속도 차이를 고려한 **흐름 제어** 기능도 지원할 수 있다.

###### (3) 네트워크 계층
**네트워크 계층**은 송신 호스트가 전송한 `데이터가 어떤 경로를 통해 수신 호스트에 전달되는 지를 결정하는 라우팅 문제를 처리`한다.
전달 경로 선택은 미리 정해지는 정적인 방식과 네트워크의 현재 부하 상태에 따라 결정되는 동적인 방식으로 구분한다.

`네트워크 계층에서는 전송 데이터`를 **패킷**이라 부르며, 중개 과정에서 경로 선택의 기준이 되는 호스트가 필요하다.
인터넷에서는 IP 프로토콜이 네트워크 계층의 기능을 수행하므로 IP 주소가 경로 선택에 중요한 기준이 된다.
인터넷에 연결된 호스트는 네트워크 계층의 주소와 데이터 링크 계층의 주소를 모두 가진다.

컴퓨터 네트워크를 이용해 전송되는 패킷이 지나치게 많으면 네트워크 전송 속도가 떨어진다.
네트워크의 전송 속도가 감소하면 프로토콜 동작에 많은 영향을 미칠 수 있는데, 네트워크 트래픽이 과도하게 증가하는 문제를 조절하는 **혼잡 제어** 기능도 네트워크 계층에서 담당한다.

###### (4) 전송 계층
전송 계층은 송신 프로세스와 수신 프로세스를 직접 연결하는 단대단 통신 기능을 제공한다.
전송 계층 아래에 있는 하위 계층은 호스트와 호스트 사이의 데이터 전송 과정에서 발생하는 문제들만 반영한다.
반면 전송 계층은 컴퓨터 내부에서 논리적으로 구축되는 통신 당사자인 프로세스 사이의 통신 문제를 다룬다.
전송 계층에서는 전송 오류율, 전송 속도 등과 같은 일반 사용자의 서비스 요구 유형에 대한 고려와 흐름 제어 기능도 제공한다.

###### (5) 세션 계층
세션 계층의 기능은 전송 계층과 거의 유사하다. 그러나 사용자에게 원격 파일 전송이나 원격 로그인 등과 같은 상위적 연결 개념인 **세션 기능**을 제공한다는 점이 다르다.
세션 계층에서는 송수신 호스트 사이의 대화 제어를 비롯해 상호 배타적인 동작을 제어하기 위한 **토큰 제어**, 일시적인 전송 장애를 해결하기 위한 **동기** 기능 등을 제공한다.

###### (6) 표현 계층
계층 5까지는 주로 데이터의 전송에 관한 내용을 다루지만 표현 계층은 `데이터의 의미와 표현 방법을 처리한다.` 즉, 통신 양단에서 서로 이해할 수 있는 표준 방식으로 데이터를 코딩하는 문제를 다룬다.

호스트의 데이터 표현 방법이 서로 다르면 상대방의 데이터를 이해할 수 있도록 적절하게 변환하는 과정이 필요하다.
요즘 보안의 중요성이 강조되는데, 데이터를 암호화 하는 기술도 표현 계층에서 다룬다. 또한 영상 정보 같은 대용량 데이터의 크기를 줄여주는 압축도 표현 계층의 주요 기능이다.

###### (7) 응용 계층
최상위의 응용 계층에서는 다양하게 존재하는 응용 환경에서 공통으로 필요한 기능을 다룬다.
응용 환경은 매우 다양해 범위가 방대하지만 인터넷에서 많이 사용하는 서비스는 FTP로부터 시작된 파일 공유 서비스이다.
텔넷이 제공하는 가상 터미널, 전자 메일 등도 대표적인 인터넷 서비스이다.

#### (3) TCP/IP 모델
인터넷은 데이터의 중개 기능을 담당하는 네트워크 계층으로 IP 프로토콜을 사용하는 네트워크이다.
따라서 인터넷을 연결하고자 하는 호스트는 반드시 IP 프로토콜을 지원해야 하며, 전송 계층은 TCP나 UDP를 사용한다.
현재 인터넷에서 주로 사용하는 IP 프로토콜은 버전 4(IPv4)이다.

##### (1) 구현 환경
인터네에 연결된 컴퓨터의 네트워크 구현 모델에서는 전송 계층까지의 기능을 시스템 공간인 운영체제 내부에 구현한다.
인터넷 환경에서 사용하는 TCP/IP와 하위 계층의 기능을 담당하는 LAN 카드 드라이버 루틴은 운영체제 영역에 속한다.
TCP/IP를 이용하려면 사용자 공간에서 네트워크 응용 기능을 지원하는 프로그램을 작성해야 한다.

![2-3  TCPIP 구현 환경](https://user-images.githubusercontent.com/56579239/157850826-f1137ba6-b1fa-41fd-8a5b-398da12757ef.jpg)

###### (1) 시스템 공간
TCP와 UDP는 시스템 운영체제인 커널 내부에 구현되므로 일반 사용자가 이 기능을 직접 이용할 수는 없다.
대신 소켓 인터페이스라는 전송 계층의 **프리미티브**를 이용해야 하는데, 소켓은 운영체제에서 시스템 콜 기능으로 구현되므로 사용자 프로그램에서 이를 호출하는 방식으로 사용한다.
TCP는 연결형 서비스를 제공하고 UDP는 비연결형 서비스를 제공한다.

인터넷 네트워크 계층은 IP로 구현되며, 네트워크 계층은 전송 패킷의 올바른 경로 선택 기능을 제공한다.
네트워크 계층 아래의 계층들은 LAN 카드와 LAN 카드를 구동하는 드라이버 루틴에 의해 구현된다.

###### (2) 사용자 공간
세션 계층부터 응용 계층까지의 기능은 사용자 프로그램으로 구현된다.
프로그래밍 환경에서 전송 계층의 기능을 제공하는 소켓 시스템 콜을 호출해 TCP와 UDP 기능을 사용할 수 있다.
소켓 시스템은 유닉스, 리눅스, 윈도우즈 운영체제 등 인터넷에 접속 가능한 모든 호스트에서 제공한다.

프로그램에서 제공하는 소켓을 사용할 때는 소켓마다 부여되는 고유 주소인 포트 번호를 관리해야 한다.
일반 네트워크 프로그램은 포트 하나를 할당해 사용하므로 포트 번호와 사용자 프로그램이 일대일로 대응된다.
응용 환경에 따라서는 포트 번호를 여러 개 할당할 수도 있다.
응용 프로그램을 설계할 때는 포트 할당에 주의해야 하지만, 일반 사용자는 프로그램 하나에 포트 하나를 사용한다고 가정해도 큰 문제가 없다.
인터넷 응용 프로그램의 고유 주소는 IP 주소와 포트 번호의 조합으로 구성된다.

상위 계층은 사용자 프로그램 공간에서 구현된다. 네트워크 응용 프로그램으로는 텔넷, FTP, 웹 브라우저 등이 있는데, 모두 TCP와 UDP를 사용해 네트워크에 연결한다.

##### (2) 프로토콜
TCP/IP 모델에서는 사용자 데이터 전송이 TCP, UDP, IP에 의해 이루어지지만, 이들이 올바르게 동작하려면 더 많은 프로토콜이 필요하다.
특히 주소 문제를 해결하기 위한 ARP/RARP와 오류 문제를 해결하기 위한 ICMP는 TCP/IP 모델에서 매우 중요한 역할을 한다.

###### (1) TCP/IP의 계층 구조
맨 위의 응용프로그램은 TCP와 UDP를 사용해 데이터 송수신 기능을 수행하지만, 네트워크 계층의 IP 프로토콜을 직접 사용하기도 한다.
ICMP와 ARP/RARP는 네트워크에 소속되어 IP의 동작을 도와준다.

![2-4  TCPIP 계층 구조](https://user-images.githubusercontent.com/56579239/157850860-3a0f3a98-7e16-4623-bb41-9694bc619b1e.jpg)

네트워크 계층의 IP는 사용자 데이터를 전송하는 프로토콜이다. IP의 동작 과정에서 전송 오류가 발생하는 경우에 대비해 오류 정보를 전송하는 목적으로 ICMP를 사용한다.
ICMP는 IP 프로토콜과 같은 계층으로 간주할 수 있지만, ICMP에서 발생하는 ICMP 메시지는 IP 패킷에 캡슐화되어 전송된다.

###### (2) ARP와 RARP
TCP/IP 모델에서 사용하는 주소는 데이터 링크 계층의 MAC 주소, 네트워크 계층의 IP 주소, 전송 계층의 포트 번호이다.
포트 번호는 사용자 프로그램 환경에서 사용되므로, 번호 할당관 관리다 다른 계층 프로토콜의 동작에 크게 영향을 미치지 않는다.

IP 주소와 MAC 주소는 프로토콜의 동작 특성 상 몇 가지 고려사항이 있다. 예를 들어, 계층 2 프로토콜을 이용해 데이터를 전송하려면 목적지 호스트의 MAC 주소가 필요하다.
일반적으로 송신 호스트는 자신의 IP 주소와 MAC 주소는 쉽게 얻을 수 있지만, 수신자의 주소를 얻으려면 몇 단계의 처리 과정이 필요하다.
먼저, 상대방의 호스트 IP 주소는 응용 프로그램의 사용자로부터 입력되지만 MAC 주소 정보는 어디에도 얻을 수 없다.
따라서 `사용자로부터 입력된 상대방 호스트의 IP 주소를 이용해 MAC 주소를 구하는 기능`이 필요한데, **AR**P가 이 기능을 담당한다.

호스트의 IP 주소는 컴퓨터 설정 작업의 초기화 과정에서 특정 파일에 보관된다. 
그러나 하드디스크가 없는 시스템은 LAN 카드에 내장된 자신의 MAC 주소는 알지만, 파일 시스템이 존재하지 않으므로 IP 주소를 알 수 없다.
이 문제를 해결하기 위하여 `MAC 주소를 IP 주소로 변환`하는 **RARP**가 필요하다.

###### (3) ICMP
데이터 전송 프로토콜인 IP가 동작하는 과정에서 전송 오류가 발생할 수 있다. `오류가 발생하면 반드시 송신자에게 회신해 복구 작업`을 하게 해야하는데, 이 작업은 **ICMP**가 담당한다.
ICMP 프로토콜은 오류 메시지를 전송하기 위한 별도의 헤더 구조를 가지며, IP 패킷에 캡슐화 되지만 IP와 같은 계층으로 취급한다.


