## (5) 상위 계층
### (1) 상위 계층의 이해
#### (1) 상위 계층 소개
상위 세 계층인 세션 계층, 표현 계층, 응용 계층은 사용자 프로그램으로 구현되는데, 일반적으로 세 계층의 기능을 하나의 프로그램으로 묶어 구현한다. 예를 들어 텔넷, FTP, 전자 메일 등의 네트워크 응용 프로그램은 상위 세 계층의 기능을 함께하는 단일 프로그램이다. 특히, 세션 계층과 표현 계층의 기능은 프로그램에 구현되지 않거나, 아주 단순화 되는 경우가 많다.

#### (2) 세션 계층
응용 환경에서 전송 계층이 제공하는 서비스를 손쉽게 이용하려면 사용자의 논리적 관점을 고려하여 단순한 사용자 인터페이스르 제공해야 한다. 세션 계층은 이러한 필요에 따라 도입되었으나, 기능이 제한적이라 다른 계층보다 상대적으로 간단한 계층에 속한다.

##### (1) 세션 계층의 기능
세션 계층 프로토콜이 상위 계층에 제공하는 기능은 세션 연결의 설정과 해제, 세션 메시지 전송 등이다. **세션 연결**은 `응용 환경에서 두 응용 프로세스 간의 세션을 설정`하기 위해 만든다. 하나의 응용 프로세스는 동시에 여러 세션 프로세스와 세션 연결을 생성할 수 있으며, 세션 연결이 설정되면 양쪽 프로세스가 **세션 메시지를 송수신**한다. 세션 사용을 종료하려면 **세션 연결 해제** 과정을 거쳐야 한다.

세션 계층에서 제공하는 가장 중요한 기능은 **동기** 문제를 처리하는 것이다. 동기 기능은 `통신 양단에서 서로 동의하는 논리적인 공통 처리 지점`, 즉 **동기점**을 지정하기 위해 사용한다. 동기점을 설정하는 이유는 `메시지 전송 과정에서 발생하는 오류를 복구`하기 위해서이다. 즉, 동기점이 설정된 시점 이전까지는 통신 양단이 서로 완벽하게 처리했음을 합의하는 의미이다. 따라서 오류가 발생했을 때 동기점 이전 과정은 복구할 필요가 없다.

`메시지 전송 과정`을 의미하는 **대화** 단계에서 오류가 발생하면, 이전에 설정한 동기점까지는 복구할 수 있다. 따라서 시간 경과에 따라 순차적으로 동기점을 부여해 신뢰성 보장 기능을 단계적으로 구현할 수 있다. 또한 현재 진행 중인 대화를 의도적으로 정지시키고 동기점을 설정하여, 나중에 해당 지점에서 작업을 이어서 진행할 수도 있다.

##### (2) 토큰
세션 계층은 두 `응용 프로세스의 대화를 관리`하려고 **토큰**이라는 특수 메시지를 사용한다. 토큰을 보유한다는 것은 해당 토큰에 부여된 `특정한 권리를 배타적으로 소유한다`는 의미이다.

###### (1) 토큰 종류
세션 계층에서 제공하는 토큰은 크게 네 가지로 데이터 토큰, 해제 토큰, 동기 토큰, 액티비티 토큰이 있다. 
- **데이터 토큰**: `데이터를 전송할 수 있는 권리를 제공`한다. 따라서 세션 사용자가 데이터를 전송하려면 반드시 데이터 토큰을 먼저 획득해야 한다. 데이터 토큰을 하나만 사용하면 통신 양단 중 한쪽에서만 데이터를 전송할 수 있다. 그러므로 데이터 토큰을 응용 프로그램 간의 `반이중 전송을 지원`하는 목적으로도 이용할 수 있다.
- **해제 토큰**: `통신 양단 간의 연결 해제 과정을 제어` 하기 위해 사용한다. 임의의 사용자가 연결을 해제하려면 해제 토큰을 획득해야 한다.
- **동기 토큰**: 세션 연결을 사용하는 과정에서 `동기 처리가 필요한 지점에 사용`한다.

###### (2) 토큰과 동기점
큰 파일을 작은 단위로 나누는 과정은 동기점을 부여하는 과정이다. 파일을 전송하는 중간 중간에 동기점을 부여함으로써, 송수신 프로세스가 해당 위치까지는 데이터 전송이 완료되었다는 것에 합의할 수 있다. 따라서 전송 과정에서 오류가 발생해도 전체 파일을 재전송하지 않고, 가장 가까운 지점에 설정한 동기점 이후의 데이터만 복구하면 된다.

##### (3) 동기
동기점을 부여하기 위한 동기 토큰은 크게 두 가지이다. 하나는 `특정 대화 단위를 구분`하는 **주동기 토큰**이고, 다른 하나는 `대화 단위 내에서 다시 작은 부분으로 나누어 처리`하는 **부동기 토큰**이다.

###### (1) 재동기 기능
동기점은 데이터를 전송할 때 특정 지점에서 복구할 수 있도록 통신 양단 간의 합의로 지정된다. 세션 계층의 상위 계층에는 적절한 구간으로 나뉜 지점에 동기점을 부여하고, 오류가 발생하면 해당 지점으로 돌아가 복구하는 기능이 구현되어야 한다. 이때 `동기점을 이용한 일련의 복구 과정`을 **재동기**라 한다.

![11-1  동기점의 역할](https://user-images.githubusercontent.com/56579239/163703047-8e9f7b14-c239-4160-abdc-b4aade5eb8d5.jpg)

동기점은 주동기와 부동기점으로 나뉘고, `주동기점 간의 전송 단위는 대화`로 정의된다. 주동기점은 두 세션 프로세스 사이에 교환되는 대화의 한 단위가 완료되는 지점에서 설정된다. `부동기점은 대화 단위 내의 작은 부분에서 설정`된다.

동기점을 주동기점과 부동기점으로 구분하는 이유는 다음과 같다. `부동기점에서는 복구에 필요한 백업 정보의 처리량을 주동기점보다 상대적으로 적게 하여, 복구에 소요되는 부담을 최소화`한다. 그러나 부동기점에 저장된 백업 정보로는 오류 복구가 완벽하게 이루어지지 않을 가능성이 있다. 이전 부동기점에서 복구가 불가능하면 바로 앞의 부동기점으로 이동하는 과정을 반복하면서 복구 과정이 진행된다. 이런 부동기점의 복구 절차가 진행되어도 복구 절차는 완전하게 이루어지지 않을 수 있다.

**재동기 처리**는 앞서 설명한 것처럼 `직전의 부동기점으로 이동하는 과정을 반복하면서 진행`되는데, 어떠한 경우에도 `주동기점의 경계를 넘어 되돌아가지 않는다.` 왜냐하면 세션 계층에서 주동기점이 부여된다는 것은 해당 지점까지 데이터 전송이 완벽하게 이루어졌다는 뜻이므로, 주동기점 이전의 복구 과정은 불필요하기 때문이다.

###### (2) 액티비티 기능
동기의 또 다른 기능으로 **액티비티**가 있다. 액티비티는 세션 프로세스 사이에 논리적으로 설정되는 단위이며, 내용이 상호 독립적이다. 예를 들어, `파일 여러 개를 전송할 때 각 파일은 하나의 액티비티로 처리`되며, 처리 과정에서 주동기점과 부동기점이 부여된다. 액티비티 단위의 시작과 끝의 표시는 주동기점의 설정과 동일한 효과를 나타낸다.

##### (4) 세션 연결
세션 계층에서 제공하는 연결은 상위 계층의 응용 프로세스가 다른 응용 프로세스에 세션을 설정하기 위해 사용한다. 즉, 초기 연결 과정에서 CONNECT 요구가 발생하면 세션 계층은 이를 전송 계층 프리미티브인 CONNECT 요구로 변환하여 전송 계층을 통해 상대편 세션 사용자에게 전달한다.

###### (1) 다중 세션 연결을 지원하는 서버
임의의 네트워크 서비스를 제공하는 `서버 프로세스가 다수의 클라이언트 프로세스에 동시에 여러 세션 연결을 설정`할 수 있다. 클라이언트 프로세스와 설정된 세션은 논리적으로 연관이 없는 `서로 독립적인 연결`이다. 

![11-2  다중 세션 연결을 지원하는 서버](https://user-images.githubusercontent.com/56579239/163703049-29f53794-b40c-40f5-954b-a79377a66d0a.jpg)

다중 세션을 지원하는 클라이언트-서버 환경은 서버가 제공하는 서비스 시간이 짧은 응용 환경에서 유용하다. 만일 클라이언트와 서버 사이의 `서비스 이용 시간이 길어지면` 특정 클라이언트와 세션 연결이 길게 유지되므로 `다른 클라이언트의 대기 시간이 무한정 증가`된다는 단점이 있다.

###### (2) 단일 세션 연결을 지원하는 서버
다중 세션 연결 방식의 문제를 해결하려면 `서버 프로세스 하나가 클라이언트 프로세스 하나와 세션 연결을 설정해 통신`해야 한다. 이런 경우에 여러 클라이언트를 동시에 지원하려면 복사된 하위 프로세스를 여러 개 만들어야 한다.

![11-3  단일 세션 연결을 지원하는 서버](https://user-images.githubusercontent.com/56579239/163703051-5ec091ef-f897-4500-b3f2-3f448c452642.jpg)

위처럼 작은 원으로 그려진 **하위 서버 프로세스**는 `하나의 세션 연결을 사용`해 클라이언트와 통신한다. 클라이언트 프로세스는 하위 서버 프로세스와 연결하기 위해 `최초의 연결 설정은 대표 서버에 시도`한다. 이는 기술적으로 대표 서버의 포트 주소가 **Well-known 포트**로 할당되므로, 클라이언트가 연결 주소를 알기 때문이다. 하위 서버는 처리 과정에서 만들어지므로 포트 번호를 Well-know 포트로 지정하기 어렵다. `대표 서버는 하위 서버 프로세스를 새로 실행시키고, 연결을 요청한 클라이언트와 세션을 연결`해준다.

이 방식의 단점은 `클라이언트의 개별 요구마다 하위 프로세스를 생성하기 때문에 초기 서비스 환경 구축에 따른 오버헤드가 증가`한다는 점이다. 즉, 프로세스를 새로 실행하고 실행 상태로 만들어주는 데 걸리는 시간이 길어 서비스 시간이 짧은 응용 환경에서는 사용하지 않는다. 대신 클라이언트가 서비스를 받으려고 무한정 기다리는 현상을 발생하지 않는다.

#### (3) 표현 계층
표현 계층은 `응용 프로세스 사이에 전송되는 메시지의 표현 방법을 다룬다.` 즉, 표현 계층 프로토콜의 `전송 메시지에 표현된 문법 내용을 통신 양단의 프로세스가 해석하는 기능`을 제공함으로써, 송신 프로세스가 전달하는 의미를 수신 프로세스에서 정확히 이해할 수 있게 한다.

##### (1) 데이터 표현
일반적으로 응용 환경에서 데이터를 표현하는 방법은 컴퓨터마다 다르다. (ex ASCII 코드, EBCDIC 코드) 서로 다른 코드를 사용하는 컴퓨터끼리 통신하려면 문자 코드를 변환하는 과정이 필요하다.

###### (1) 추상 문법
![11-4  추상 문법과 전송 문법](https://user-images.githubusercontent.com/56579239/163703052-9512d784-f317-482b-9e85-e74ac574f794.jpg)

컴퓨터에서 사용하는 데이터 표현 규칙인 **추상 문법**으로 표현된 의미를 올바르게 송수신하려면 메시지를 전송하기 전에 변환해야 한다. 즉, 특정 컴퓨터에 독립적이면서 네트워크 전체에 일관성 있는 표현 규칙인 **전송 문법**으로 변환하여 전송한다. 이렇게 함으로써 전송 선로를 통해 교환되는 데이터는 공통의 표현 규칙인 전송 문법으로 표현된다. 반대로 네트워크에서 데이터를 수신할 때는 전송 문법의 데이터를 자신이 이해하는 추상 문법으로 변환한다.

###### (2) ASN.1
ISO는 `분산 환경에서 표현되는 데이터를 정의하기 위한 일반적인 추상 문법`으로 ASN.1을 정의하였다. ASN.1은 응용 환경에서 폭넓게 사용된다. ASN.1 규격은 응용 계층의 문법뿐 아니라, PDU의 구조를 정의하도록 만들어졌다. 기본 목적은 변수 선언과 관련된 데이터 형의 정의인데, 일반 프로그래밍 언어에서 사용하는 방식과 비슷한 문법 형식을 지원한다.

###### (3) 보안
최근 많은 응용 프로그램에서 필요한 암호화 기능도 표현 계층에 속한다. 암호화는 데이터를 송수신하는 당사자 외에 제3자에게 부당하게 정보가 유출되거나 왜곡되는 현상을 방지한다.

##### (2) 데이터 압축
네트워크 사용자에게 전송되는 데이터의 신뢰성과 함께 전송 속도도 중요한 고려 사항이다. 인터넷 환경에서는 대용량 멀티미디어 데이터를 많이 다룬다. 특히 대용량 실시간 데이터는 전송할 때 데이터의 신뢰성보다 시간 특성이 더 강조된다.

`대용량 데이터는 압축하여 크기를 줄인 후 전송하는 것이 전송 속도 면에서 유리`하다. 데이터의 압축 정도는 원래 데이터 패턴에 영향을 받는데, 중복 정보가 많으면 압축률이 높지만 그렇지 않은 경우는 낮다. 예를 들어, 이미 압축된 데이터를 다시 압축하는 것은 무의미하다. 압축된 데이터의 내용에는 중복 정보가 더 이상 없다고 보아야 하기 때문이다. 

동일한 데이터에 어떤 알고리즘을 적용하느냐에 따라 압축률이 달라진다. 이는 원래 데이터에 포함된 정보의 특성을 미리 알면 더 효과적으로 압축할 수 있다는 의미이다. 따라서 일반적으로 가장 좋은 압축 알고리즘이란 없으며, `데이터의 특성에 맞는 알고리즘을 사용하는 것이 중요`하다.

###### (1) 연속 문자 압축의 예
![11-5  데이터 압축 예](https://user-images.githubusercontent.com/56579239/163703060-f9e04a73-39bb-4922-b7f0-e96ac54f57a1.png)

###### (2) 손실, 비손실 데이터 압축
![11-6  손실, 비손실 압축](https://user-images.githubusercontent.com/56579239/163703062-68127731-734a-4843-a897-30b7217dd778.jpg)

데이터를 압축하는 유형에는 비손실 압축과 손실 압축이 있다. **비손실 압축**은 `압축 과정에서 원래 데이터의 내용을 분실하지 않는다.` 즉, 압축 해제를 통해 얻은 데이터가 압축 이전의 데이터와 완전히 동일하다. (b)처럼 비손실 압축 알고리즘을 사용해 압축 데이터를 복원하면 원래 데이터를 얻을 수 있다.

이에 비해 **손실 압축**은 `압축 해제한 데이터가 원래 데이터와 동일하지 않다.` 데이터 손실 정도는 응용 환경에 따라 허용 범위가 다르다. 예를 들어, 화상 정보나 음성 정보처럼 사람들이 감각적으로 느끼는 정보는 사용자 환경에 따라 손실 범위를 조절할 수 있다. 원래 데이터의 손실을 허용하면서 압축하는 이유는 `압축 효율을 높이기 위함이다.` 손실 압축을 사용하는 이유는 비손실 압축 데이터의 크기가 작기 때문이다. 따라서 네트워크로 전송되는 데이터의 양도 줄게 되어 `전송 효율을 높일 수 있다.`

#### (4) 응용 계층
응용 계층의 하부에 있는 계층들은 신뢰성 있는 데이터 전송을 보장하는 역할을 수행한다. 이에 비해 응용 계층은 `하부 계층들을 이용해 사용자에게 편리한 응용 환경을 제공`하는 것에 초점을 둔다. 따라서 응용 계층의 `구현은 사용자 프로그램 환경`에서 이루어지며 운영체제에서 제공되는 `계층 4의 인터페이스를 사용해 통신` 기능을 구현한다. 필요에 따라 세션, 표현 계층의 기능을 포함한다.

##### (1) 클라이언트-서버 모델
![11-7  클라이언트와 서버의 연결](https://user-images.githubusercontent.com/56579239/163703064-71b7a9e1-ad1f-4a22-b62f-650337015b7d.jpg)
응용 계층의 연결 설정 방식에는 하나의 서버 프로그램이 다수의 클라이언트에 응용 서비스를 제공하는 클라이언트-서버 모델이 있다. `서버가 반드시 먼저 대기 상태`에 있어서 `클라이언트가 서버에게 연결 요청`을 하는 것으로 연결을 설정한다.

###### (1) 연결형, 비연결형 서비스
클라이언트-서버 모델을 구현할 때 먼저 고려할 사항은 비연결형과 연결형 서비스 중에서 어떤 방식을 사용하는 것인지 이다. 연결형 서비스인 TCP는 신뢰성이 높지만 상대적으로 속도가 떨어진다. 이에 비해 비연결형 서비스인 UDP는 상대적으로 전송 속도에서 빠르지만 데이터 분실이나 비순서 도착과 같은 단점을 가지고 있어 응용 프로그래머의 부담이 커진다.

###### (2) 상태 정보
연결형 서비스는 클라이언트와 서버 사이의 연결로 `특정 상황에 대해서 통신 양단이 바라보는 관점`인 **상태 정보**를 가진다. 오류가 발생시 서로 합의할 수 있는 상태로 되돌아가는 과정으로 상태 정보를 이용하여 복구 과정을 할 수 있다. **비상태 서비스**도 존재하는데 비상태 서비스는 상태가 없으므로 복구 과정이 간단하지만 보안의 문제로 보안이 강화되는 환경에서는 상태 서비스를 선호한다.

###### (3) 동시성 제어
**동시성**은 `임의의 동작이 외형상 동시에 진행되는 것으로 보이는 현상`이다. 여러 동작의 선후 진행 속도가 실행 결과에 영향을 미치지 않게 한다. 클라이언트-서버 모델은 동시성 제어의 기능을 제공하는데 서버 하나가 여러 클라이언트에 동시에 서비스를 하기 때문이다. 즉 임의의 클라이언트가 서버와 연결하여 서비스를 받는 동안 다른 클라이언트의 요청을 서버가 지원하면 동시성을 지원한다고 볼 수 있다.

서비스 방식에는 반복 서비스 방식과 동시성 서비스 방식이 있는데 서버 하나가 다수의 클라이언트를 지원하지만 `특정 시간에는 클라이언트 하나만 서비스를 제공`할 경우를 **반복 서비스 방식**이라고 한다. 이에 반해 동시성을 제공해주는 즉 클라이언트 요청이 발생할 때마다 서버와 동일한 `하위 서버 프로세스를 생성하여 요청을 수행`하는 **동시성 서비스** 방식이 있다.

<Br>
<Br>
<Br>

###### [참고 자료](https://copycode.tistory.com/111?category=740132)
