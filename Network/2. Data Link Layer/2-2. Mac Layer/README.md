## (2) 데이터 링크 계층

### (2) MAC 계층

#### (1) MAC 계층과 IEEE 802 시리즈

##### (1) MAC 계층의 이해

LNA 환경에서는 네트워크 자원을 효율적으로 활용하기 위해 데이터 링크 계층의 기능을 LLC 계층과 MAC 계층으로 나누어 처리한다. OSI 7계층 모델에서 정의한 `데이터 링크 계층의 기본 기능`은 주로 **LLC 계층**에서 다루고, `물리적인 전송 선로의 특징과 매체 간의 연결 방식에 따른 제어` 부분은 **MAC 계층**에서 주로 다룬다. WAN 환경과 비교해보면 LAN의 LLC 계층이 WAN의 데이터 링크 계층과 역할이 비슷하여, LAN 환경에서는 MAC 계층이 추가된 것으로 볼 수 있다.

###### (1) MAC 계층

**MAC 계층**은 전송 선로의 물리적인 특성을 반영하므로 LAN의 종류에 따라 특성이 분류된다. LAN 환경을 위한 MAC 계층은 종류가 다양한데, 공유 버스 방식을 지원하는 이더넷과 링 구조를 지원하는 토큰 링 방식이 대표적인 예이다.
컴퓨터 네트워크에서 가장 많이 사용하는 **이더넷**은 `공유 버스를 이용해 호스트를 연결`한다. 이더넷에서는 데이터를 전송하기 전에 전송 선로를 먼저 확인해 다른 호스트가 데이터를 전송 중인지 여부를 파악해야 한다. 다른 호스트가 전송 선로를 사용하지 않으면 데이터 프레임을 전송할 수 있지만, 사용하고 있다면 정해진 정책에 따라 나중에 다시 시도해야 한다. 둘 이상의 호스트에서 동시에 데이터 프레임 전송을 시도하는 **충돌**이 생기면 호스트는 이를 감지하고, 일정 시점이 지난 후에 재전송 해야 한다.
**토큰 링** 방식은 `토큰이라는 특정 패턴의 제어 데이터가 링을 순환`한다. 데이터 프레임을 전송하려면 먼저 토큰을 확보해야 하며, 전송을 완료하자마자 토큰을 링에 내놓아야 한다. 토큰링 방식에서는 각 호스트에 전송 우선순위를 부여할 수 있다.

###### (2) LCC 계층

LAN 환경에서 **LLC 계층**은 6장에서 소개한 `WAN 환경의 데이터 링크 계층과 기능이 거의 유사`하다. 그러나 LAN 종류에 따라 MAC 계층의 설계 형태가 영향을 받는 것처럼, LLC 계층도 `LAN의 특성에 부분적 영향`을 받을 수 있다. 그러므로 이더넷에서 사용하는 LLC와 토큰 링에서 사용하는 LLC는 약간 다를 수 있다.
예를 들어, **이더넷**의 LLC 계층은 `프레임을 전송하는 과정에서 슬라이딩 윈도우 프로토콜을 사용`한다. 반면 **토큰 링**이나 **토큰 버스 구조**에서는 송신 호스트가 수신 호스트의 도움 없이, 보낸 프레임의 전송 오류를 검출하고 재전송 하는 기능을 수행할 수 있어 `슬라이딩 윈도우 프로토콜이 불필요`하다.

##### (2) IEEE 802 시리즈

국제 표준화 단체인 IEEE에서 데이터 링크 계층과 관련된 `LAN 표준안 연구 결과`를 **IEEE 802** 시리즈로 발표했다. IEEE 802.1은 관련 표준안 전체를 소개하고 인터페이스 프리미티브에 대한 정의를 다루며, IEEE 802.2는 데이터 링크 계층의 상위 부분인 LLC 프로토콜의 정의를 다룬다.
IEEE 802.3 표준안부터 MAC 계층에 대한 내용을 주로 다루는데, IEEE 802.3은 이더넷으로 알려진 CSMA/CD 방식, IEEE 802.4는 토큰 버스 방식, IEEE 802.5는 토큰 링 방식에 대한 내용을 규정한다.
네트워크 계층과 LLC 계층의 기능은 LAN 종류에 큰 영향을 받지 않으므로 공통의 프로토콜인 IEEE 802.2 표준안을 사용한다. 그러나 MAC 계층은 물리 계층의 종류에 따라서 다양하게 사용될 수 있으므로, 각각에 대하여 별도의 표준안이 정의되어 있다.

###### (1) CSMA/CD

다중 접근 채널 방식을 이용하여 공유 매체에 프레임을 전송하는 방식에서는 데이터 충돌 가능성이 항상 존재한다. **충돌 문제를 해결하는 방법**은 크게 두 가지이다. 하나는 다수의 호스트가 송신한 프레임이 공유 매체에서 `충돌하는 현상을 허용하는 방식`으로, 충돌이 발생한 후에 문제를 해결한다. 다른 하나는 `충돌이 발생할 가능성을 원칙적으로 차단하는 방식`이다.
충돌을 허용하는 방식의 대표적인 예는 이더넷으로 더 많이 알려진 **CSMA/CS**이다. 충돌 허용 방식에서는 충돌로 깨진 프레임을 복구하는 작업이 필요하기 때문에 송신한 호스트에서 `충돌을 감지하는기 기능`이 반드시 필요하다. CSMA/CD 방식에서 `충돌이 자주 발생`하면 오류 복구 과정에 따라 재전송도 많이 이루어진다. 따라서 동일한 프레임을 여러 번 재전송하는 과정을 반복하므로 `네트워크의 전체 성능이 떨어진다.` 일반적으로 공유 매체의 길이가 길수록 프레임의 전송 지연이 증가하여 충돌이 발생할 가능성도 높아진다.
전송 프레임은 버스 구조에 연결된 모든 호스트에 전송되기 때문에 목적지가 아닌 호스트에도 도착한다. 목적지 호스트가 아닌 호스트에서는 이 프레임을 수신할 이유가 없으므로 버려야 한다. 이 기능을 지우너하기 위해 각 호스트에는 **고유 주소**가 할당된다. 전송 프레임에는 목적지 호스트를 지정한 후 프레임을 전송해야 하며, 목적지 주소와 자신의 주소가 일치하지 않는 호스트는 프레임을 무시할 수 있다.

###### (2) 토큰 버스

![5-1  토큰 버스](https://user-images.githubusercontent.com/56579239/158882776-09229de8-9de2-4f70-96d0-7c7e2af15df7.png)

**토큰 버스** 방식은 다음과 같이 물리적인 버스 구조(점선)로 연결되지만 논리적인 프레임 전달은 링 구조(실선)이다. 토큰 버스에서는 호스트 사이의 데이터 프레임 전송이 순차적으로 이루어지도록 **토큰**이라는 제어 프레임을 사용한다.
프레임을 전송하려면 반드시 토큰을 확보해야 한다. `프레임 전송을 원하는 호스트`는 토큰이 도착할 때까지 기다려서 도착한 `토큰을 획득한 뒤 프레임을 전송`한다. `전송을 완료`하면 이웃 호스트에 `토큰을 넘겨준다.` 호스트가 이웃하는 순서는 물리적인 순서가 아닌 각 호스트의 고유 번호와 관련 있다. 높은 번호부터 네트워크에 연결되고, 토큰 전달도 먼저 이루어진다.

###### (3) 토큰 링

순환 구조의 전송 매체와 연결되는 링 인터페이스의 동작은 대기 모드와 전송 모드로 구분된다. **대기 모드**에서는 `입력단으로 들어온 비트를 출력단으로 즉시 내보낸다.` 따라서 호스트가 다운되거나 기타 장애가 발생하면 대기 모드가 되어 네트워크의 동작에 영향을 주지 않는다. 대기 모드에서 호스트는 링 네트워크를 유지하는 역할만 수행한다.
**전송 모드**는 호스트가 `토큰을 획득해 프레임을 전송할 수 있는 권한을 보유한 상태`이다. 이때는 네트워크의 입력단과 출력단의 논리적인 연결이 끊어지는 대신 네트워크가 호스트의 중개를 거쳐서 연결된다. 호스트는 전송하고자 하는 프레임을 출력단을 통해 링으로 내보낼 수 있다.
**토큰 링** 방식에서는 송신 호스트가 전송한 프레임이 링을 한 바퀴 돈 후 송신 호스트에 되돌아오도록 설계 된다. 이 과정에서 프레임의 목적지 주소가 자신의 주소와 동일한 호스트는 해당 프레임을 수신하고, 프레임 내부의 특정 위치에 올바로 수신했다고 표시한다. 송신 호스트는 자신에게 되돌아온 프레임의 특정 위치 값을 확인하여 프레임이 올바로 전송되었음을 확인한 뒤, 데이터 프레임을 회수하고 토큰 프레임을 링에 반환한다.

#### (2) 이더넷

##### (1) 이더넷과 신호 감지 기능(CS)
공유 버스 구조에서 호스트 간의 프레임 충돌을 방지하려면 프레임을 전송하기 전에 다른 호스트가 공유 버스를 사용하고 있는지 확인해야 한다. 이는 전송 선로에 흐르는 신호를 감지하는 기능으로 구현할 수 있다. `전송 매체의 신호를 감지해 프레임의 전송 여부를 결정하는 프로토콜`을 **신호 감지 프로토콜**이라 한다. 신호 감지 프로토콜에서는 선로의 전달 지연이 성능에 영향을 많이 준다.

###### (1) 1-persistent CSMA
신호 감지 프로토콜 중에서 가장 간단한 형태는 **1-persistent CSMA** 방식이다. 이 방식은 일반 신호 감지 프로토콜처럼 프레임을 전송하기 전에 전송 채널이 사용 중인지 확인한다. `다른 호스트에서 채널을 사용 중이라고 판단하면 유휴 상태가 될 때까지 대기`한다. 그러다가 임의의 순간에 `채널이 유휴 상태로 변경되면 확률 1의 조건으로 프레임을 무조건 전송`하기 때문에 1-persistent CSMA라 한다.
둘 이상의 호스트에서 동시에 전송 채널을 유휴 상태로 판단하면 프레임 전송 과정에서 충돌이 발생할 수 있다. 충돌이 발생하면 임의의 시간 동안 대기한 후에 전송 채널을 감지하는 과정을 다시 반복한다.

###### (2) Non-persistent CSMA
**Non-persistent CSMA** 방식에는 전송 채널의 신호를 감지해 채널이 사용 중이라고 판단하면 더는 `채널의 유휴 상태를 확인하지 않는다.` 대신 `임의의 시간 동안 기다린 후에 다시 채널 감지를 시작`하기 때문에 1-persistent 방식보다 충돌이 발생할 확률을 줄일 수 있다. 1-persistent 방식에서는 여러 호스트가 채널이 유휴 상태가 되기를 기다리다가 동시에 프레임을 전송할 수 있기 때문에 충돌이 발생할 가능성이 높다.

###### (3) p-persistent CSMA
**p-persistent CSMA** 방식은 슬롯 채널 방식에서 많이 사용한다. 채널이 유휴 상태이면 p이 확률로 프레임을 전송하고, 채널이 사용 중이면 다음 슬롯을 기다린 후 앞의 과정을 반복한다.

###### (4) CSMA/CD
공유 버스에서 충돌이 발생하면 해당 프레임의 내용이 깨지고, 각 호스트에서 전송한 프레임의 내용이 변형되므로 프레임을 전송하는 것이 의미가 없다. 따라서 향상된 방식인 CSMA/CD에서는 **충돌 감지(CD)** 기능을 사용해 충돌 여부를 확인한다. 일단 호스트가 충돌을 감지하면 진행 중인 프레임의 전송을 중지한다.

![5-2  이더넷의 연결](https://user-images.githubusercontent.com/56579239/158882791-9cac517e-371c-4fe5-a157-a9b6ceaf9b9c.jpg)

다음은 이더넷의 예시를 보여준다. 굵고 긴 전송 케이블로 된 전송 매체에 트랜시버 장비로 보조선을 연결해 각 호스트를 연결한다. **트랜시버**는 `호스트를 전송 케이블에 연결하기 위한 송수신 장치`로, 전송 선로의 신호를 감지하는 기능과 함께 충돌 현상을 감지하는 기능도 제공한다. 임의의 트랜시버가 충돌을 감지하면 이를 특정 신호의 형태로 변환해 전송 케이블에 다시 전송해야 한다. 이처럼 `트랜시버는 충돌이 발생했음을 알려줌으로써 무의미한 프레임 전송을 억제`한다.

##### (2) 프레임 구조
상위 계층인 LLC 계층에서 내려온 프레임을 상대 호스트에 전송하려면 MAC 계층에서 정의된 프레임 구조에 맞게 포장해야 한다. `전송 데이터 프레임에 MAC 계층 프로토콜에서 정의된 MAC 헤더와 트레일러 정보를 추가한 것`을 **MAC 프레임**이라 하며, 이더넷 프로토콜에서는 이더넷 프레임이라 한다. MAC 프레임은 LLC 계층에서 보낸 모든 정보를 전송 데이터로 취급하며, 데이터 앞에는 헤더가, 뒤에는 트레일러가 위치한다.

![5-3  이더넷 프레임 구조](https://user-images.githubusercontent.com/56579239/158882802-d8a1e8c6-c27d-496e-9a7e-785622b72675.png)

다음은 **이더넷 프레임** 구조이다. Data 필드 왼쪽에 위치한 필드들은 헤더에 속하고, 오른쪽은 트레일러에 속한다. 헤더와 트레일러의 의미는 다음과 같다.

- **Preamble**: 7 바이트의 크기로, 수신 호스트가 송신 호스트의 클록과 동기를 맞출 수 있도록 시간 여유를 제공하는 것이 목적이다. 각 바이트는 10101010 비트 패턴을 포함한다.
- **Start Delimiter**: 프레임이 시작된다는 의미로 사용되며, Preamble 필드와 구분하기 위해 10101011의 값을 갖는다.
- **Source Address/Destination Address**: LAN 카드에서 제공하는 MAC 주소 값을 사용하여, 전송되는 프레임의 송신 호스트와 수신 호스트 주소를 표현한다. 수신 호스트 주소는 최상위 비트가 1이면 그룹 주소를 의미하고, 0이면 일반 주소이다. 그룹 주소에는 멀티 캐스팅과 브로드캐스팅이 있다.
- **Length/Type**: 필드 값이 1500 이하이면 Data 필드의 데이터 크기를 의미하는 Length로 해석하고 그렇지 않으면 Type으로 해석한다.
- **Length**: Data 필드에 포함된 가변 길이의 전송 데이터 크기를 나타내며, 최댓값은 1500이다. IP 패킷의 크기가 이 값을 초과하면 먼저 분할 과정이 이루어져야, MAC 프레임의 내부에 캡슐화 될 수 있다. Data와 Padding을 합한 데이터의 최소 크기는 46 바이트이다. Length 값이 46보다 작으면 Padding 필드에 해당하는 크기만큼 0으로 채운다.
- **Type**: 이더넷 프레임에 캡슐화된 상위 프로토콜의 패킷 종류를 구분한다.
- **Checksum**: 데이터 전송 과정에서 데이터 변형 오류의 발생 여부를 수신 호스트가 확인할 수 있도록 송신 호스트가 값을 기록해준다. Preamble, Start Delimiter, Checksum을 제외한 나머지 필드에 대한 CRC 값이다.

##### (3) LLC 프레임 캡슐화
네트워크 계층에서 전송을 요구한 패킷은 LLC 계층으로 내려오면서, LLC 헤더 정보를 추가해 LLC 프레임이 된다. LLC 프레임은 다시 MAC 계층으로 내려오면서, MAC 헤더와 MAC 트레일러 정보를 추가한다. 이때 LLC 계층에서 보낸 LLC 헤더와 LLC 데이터는 MAC 계층의 데이터로 취급되기 때문에 MAC 프레임의 Data 필드에 기록된다. 이후 MAC 계층에서는 MAC 프레임을 물리 계층을 사용하여 수신 호스트에 전송한다.

##### (4) 허브와 스위치
CSMA/CD 방식에서 트랜시버를 이용해 전송 케이블에 호스트를 연결하는 방식은 더 이상 사용하지 않는다. 대신 허브라는 박스 형태의 장비에 잭을 사용해 호스트를 연결하기 때문에 LAN 케이블의 구성이 이전보다 간단해졌다. 허브의 성능 문제를 개선한 스위치 허브도 많이 보급되는 추세이다.

![5-4  허브와 스위치](https://user-images.githubusercontent.com/56579239/158882819-3e96a555-fe3e-4430-85a8-d6519a82c5e9.png)

다음은 이더넷 환경에서 사용하는 공유 버스, 일반 허브, 스위치 허브의 차이점을 설명한다. (a)는 `공유 버스 구조`를 사용하는 **이더넷**의 전형적인 원리를 보여준다. 임의의 호스트에서 전송한 프레임은 모든 호스트에 전송되고, 목적지의 주소에 해당하는 호스트만 프레임을 수신한다.

###### (1) 허브
(b)와 같은 **허브** 구조에서는 `박스 형태의 장비에 호스트를 연결하는 다수의 포트를 지원`하므로, 각 호스트는 외형상 허브에 스타형 구조로 연결된다. 그러나 `내부의 동작 원리는 버스형 구조`를 지원하기 때문에 임의의 호스트에서 전송한 프레임을 허브에 연결된 모든 호스트에 전달한다.

###### (2) 스위치
(c)에 보이는 **스위치 허브**는 일반 허브와 형태가 동일하지만, 성능 면에서 장점이 있다. 중앙에 위치한 허브에 스위치 기능이 있어 임의의 호스트로부터 수신한 프레임을 모든 호스트에 전송하지 않고 `해당 프레임의 목적지로 지정한 호스트에만 전송`한다. 따라서 이들 사이에 프레임 전송이 진행되고 있어도, 다른 호스트끼리 프레임을 전송할 수 있다. 스위치 허브의 장점은 다음과 같다.
- 스위치 허브가 자신에게 연결된 호스트를 모두 수용할 수 있는 충분한 전송 용량을 지원하면 각 호스트는 할당된 LAN 전송 용량을 모두 사용할 수 있다.
- 일반 허브를 스위치 허브로 교체하는 과정에서 연결된 호스트는 하드웨어나 소프트웨어를 교체 할 필요가 없다.

#### (3) 토큰 버스

토큰 버스 프레임 구조는 CSMA/CD 프레임 구조와 거의 비슷하나 중요한 차이점이 있다. 토큰 버스 프레임에는 데이터 프레임과 토큰 프레임을 구분하기 위한 Frame Control 필드가 추가되어 있다. 이더넷 프레임에 비해 다른 토큰 버스 프레임의 필드의 기능은 다음과 같다.
- **Start Delimiter/End Delimiter**: `프레임의 시작과 끝을 의미하는 경계 표시`를 한다. 이더넷 프레임에는 Length 필드가 있어서 프레임 전체 크기를 가늠하지만, 토큰 버스에서는 End Delimiter 필드가 이 역할을 한다.
- **Frame Control**: 데이터 프레임과 제어 프레임을 구분해준다. 데이터 프레임에서는 프레임 우선순위와 수신 호스트의 응답 확인이 필요할 때 사용하고, 제어 프레임에서는 토큰의 전달, 링관리와 같은 용도로 사용한다.

#### (4) 토큰 링

##### (1) 프레임 구조
**토큰 링 프레임**은 데이터 프레임과 토큰 프레임으로 구분할 수 있다. 토큰 프레임은 Start Delimiter, Access Control, End Delimiter 필드 세 개로 구성되어 있다.

![5-5  토큰 링 프레임의 구조](https://user-images.githubusercontent.com/56579239/158882826-e6d96cb6-faa6-4286-b7d2-379257e6fcc8.png)

링에 연결된 호스트 중에는 `다른 호스트와 구별되는 특별한 기능을 수행하는 관리 호스트`가 존재하는데 이를 **모니터**라 부른다. 모니터로 지정된 호스트는 `네트워크 관리`와 관련된 기능을 수행하는데, 주로 네트워크의 정상 동작을 방해하는 예기치 않은 오류를 복구한다.

##### (2) 프레임 필드의 의미
토큰 버스 프로토콜에서와 용도가 다른 필드들의 기능은 다음과 같다.

###### (1) Start Delimiter/End Delimiter
**SD/ED** 필드는 프레임의 시작과 끝을 구분한다. End Delimiter 필드에는 I와 E라는 두 종류의 비트가 정의되어 있다. I 비트는 데이터 프레임을 여러 개로 나누어 전송하는 경우에 사용된다. 데이터의 처음과 중간 프레임은 I 비트의 값을 1로 지정해 전송ㅎ고 마지막 프레임은 값을 0으로 지정하여 데이터를 구분한다. E 비트는 오류 검출용으로 사용한다.

###### (2) Access Control
**AC** 필드는 여러 가지 제어 기능을 수행하기 위해 사용한다. 다음 그림처럼 우선순위 비트, 토큰 비트, 모니터 비트, 예약 비트로 나뉜다.

![5-6  Access Control 필드](https://user-images.githubusercontent.com/56579239/158882839-e344356a-8c7a-41ed-b35a-59c2a323b379.png)

Access Control 필드에 정의된 비트 플래그의 역할은 다음과 같다.
- **우선순위 비트**: 토큰의 우선순위보다 높은 프레임을 전송할 수 있도록 해준다.
- **토큰 비트**: 토큰 프레임과 일반 프레임을 구분한다.
- **모니터 비트**: 네트워크에 오류가 발생하면 특정 프레임이 링 주위를 무한정 순환하는 현상이 발생할 수 있다. 이를 방지하기 위해 모니터 호스트는 데이터 프레임이 자신을 지나갈 때 M 비트를 1로 지정한다. M 비트가 1인 프레임이 다시 모니터 호스트를 지나가면 이 프레임을 제거함으로써, 특정 데이터 프레임이 무한정 순환하는 현상을 방지한다.

###### (3) Frame Control
**FC** 필드는 LLC 계층에서 목적지 호스트로 전송해줄 것을 요청한 LLC 프레임과 토큰 링 프로토콜에서 사용하는 제어용 프레임을 구분하는 데 사용한다.

###### (4) Frame Status
**FS** 필드는 토큰 링 프레임의 맨 마지막에 위치하여, 프레임의 수신 호스트가 송신 호스트에 응답할 수 있도록 한다. 두 개의 플래그 비트 A, C 필드로 정의되며, 두 필드의 값이 쌍으로 존재한다. 따라서 한 쌍의 갑이 동일한 경우에만 유효한 응답으로 정의도고 다르면 0으로 처리되어 무시된다.
- **A 비트**: 목적지로 지정한 호스트에서 데이터 프레임이 링 인터페이스를 통해 자신에게 전달되면 접근 했다는 표시로 A 비트를 1로 지정한다. 데이터 프레임의 수신 호스트 주소가 자신의 주소와 다르면 링 인터페이스를 그냥 통과시킨다. 따라서 A 비트의 용도는 `목적지 호스트가 링 네트워크에서 제대로 동작하는지 확인하는 것`이다.
- **C 비트**: 입력된 데이터 프레임의 `수신 호스트 주소가 자신의 주소와 동일한 프레임이 지나가면 프레임을 내부 버퍼에 보관하고 c 비트를 1로 지정`한다. C 비트가 1로 지정된 프레임이 다시 송신 호스트에 돌아가면 송신 호스트는 A와 C 비트를 점검해 수신 호스트가 데이터 프레임을 제대로 수신 했는지 알 수 있다.
