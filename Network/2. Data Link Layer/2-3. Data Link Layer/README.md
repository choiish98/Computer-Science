## (3) 데이터 링크 계층

### (3) 데이터 링크 계층

#### (1) 데이터 링크 계층 프로토콜의 기초
물리 계층을 통해 이루어지는 두 호스트 간의 데이터 전송 과정에서 물리적인 전송 오류가 발생할 수 있다. 이 같은 `물리적인 오류를 복구하는 것`은 **데이터 링크 계층의 기본 역할**이다. 따라서 데이터 링크 계층은 상위 계층에 신뢰성 있는 데이터 전송을 보장한다. 신뢰성 있는 논리 선로를 제공하기 위한 오류 제어 방식으로 **재전송** 기법을 사용한다. 재전송 기법은 `전송한 프레임에 오류가 발생하면 송신 호스트가 전송 데이터를 재전송 하여 오류를 복구하는 것`이다.

##### (1) 프레임의 종류
- **정보 프레임**: 정보 프레임은 상위 계층이 `전송을 요구한 데이터를 수신 호스트에 전송하는 용도`로 사용한다. 약칭하여 I 프레임으로도 표기하며, 상위 게층에서 보낸 데이터와 함께 프레임의 순서 번호, 송수신 호스트의 주소 정보를 포함한다.
- **긍정 응답 프레임**: 정보 프레임을 수신한 호스트는 맨 먼저 프레임의 내용이 깨졌는지 확인해야 한다. 프레임 변형 오류가 발생하지 않으면 `송신 호스트에 해당 프레임을 올바르게 수신했다`는 의미로 **ACK 프레임**, **긍정 응답**을 회신한다.
- **부정 응답 프레임**: 정보 프레임의 전송 과정에서 프레임 변형 오류가 발생하면 수신 호스트는 송신 호스트에 **NAK 프레임**을 회신한다. 즉, **부정 응답**을 전달하여 송신 호스트가 오류 발생을 인지하고 원래의 정보 프레임을 재전송하도록 요청하는 것이다.

정보 프레임 뿐 아니라 긍정 응답, 부정 응답 프레임도 회신하고자 하는 정보 프레임의 순서 번호가 포함된다. 따라서 정보 프레임의 송신 호스트는 몇 번 프레임이 제대로 도착하고, 몇 번 프레임에서 오류가 발생했는 지를 응답 프레임의 순서 번호로 판단할 수 있다. 이 세 가지 프레임을 사용해 데이터 링크 계층의 전솟ㅇ 프로토콜을 작성할 수 있따. 프로토콜의 설계 과정에서 다루는 내용은 주로 `오류 제어, 흐름 제어, 양방향 및 단방향 전송 방식` 등이다.

##### (2) 프로토콜의 흐름 제어
수신 호스트의 버퍼 개수가 제한되면 송신 호스트가 전송한 정보 프레임의 수신 작업이 늦어질 때, 버퍼에 일시적으로 보관할 수 있는 프레임의 개수가 제한된다. 따라서 버퍼 용량 부족으로 프레임 분실 오류가 발생할 가능성이 있으므로 송수신 호스트 사이의 **흐름 제어** 기능이 필요하다.
흐름 제어는 주로 `수신 호스트가 송신 호스트의 프레임 전송 시점을 제어하는 형태`로 이루어진다. 가장 간단한 형태는 숫니 호스트가 이전 프레임의 수신을 완료한 후에 다음 프레임을 전송하도록 송신 호스트에 지시하는 것이다. 이때 사용하는 프레임이 **ACK 프레임**이다. 결과적으로 ACK 프레임은 `송신 호스트에 이전 프레임을 잘 받았다는 긍정 응답의 기능`을 수행하는 동시에, `다음 프레임을 전송하도록 지시`하는 흐름 제어 기능도 한다.
송신 호스트가 정보 프레임을 전송하고, 이어서 다음 프레임을 전송하려면 ACK 프레임이 도착하기를 기다려야 한다. 이처럼 각 정보 프레임에 대하여 `수신 호스트가 회신하는 ACK 프레임이 도착해야 다음 프레임을 전송할 수 있는 프로토콜 방식`을 **정지-대기** 방식이라 한다. 일반 네트워크 환경에서는 정지-대기 방식은 효율이 매우 떨어지므로 사용하지 않는다.

##### (3) 단방향 프로토콜
오류 제어와 흐름 제어가 필요한 통신 환경에서 송신 호스트가 전송한 정보 프레임에 발생할 수 있는 오류에는 프레임 분실 오류와 프레임 변형 오류가 있다. 프레임 분실은 전송된 프레임이 수신 호스트에 도달하지 못하고 전송 도중에 사라지는 경우이다. 이때 수신 호스트는 정보 프레임이 도착하길 무한정 기다린다. 결과적으로 수신 호스트가 ACK 프레임을 회신할 수 없으므로 송신 호스트도 ACK 프레임의 도착을 무한정 기다린다.

###### (1) NAK가 없는 경우
NAK 프레임이 정의되지 않은 프로토콜에서 송신 호스트가 전송한 정보 프레임을 분실한 경우, 수신 호스트는 받은 것이 없으므로 정보 프레임에 대한 응답 프레임을 회신할 수 없다. 송신 호스트는 ACK 프레임이 도착하기를 무한정 기다리고 프로토콜의 진행을 멈추는 현상이 발생할 수 있다. 이런 현상을 예방하려면 송신 호스트의 **타입 아웃** 기능이 반드시 필요하다. `정보 프레임을 전송한 후에 특정 시간이 지날 때까지 수신 호스트의 ACK/NAK 프레임을 회신받지 못하면 송신 호스트의 타임아웃 기능이 동작하여 분실된 프레임을 재전송하는 방식으로 복구`한다.
이는 프레임 변형 오류에도 동일하게 적용된다. NAK 프레임이 정의되지 않아 수신 호스트가 프레임 변형 오류에 응다할 방법이 없다. 따라서 타임아웃 기능에 의하여 오류 복구 기능이 진행되어야 한다.

###### (2) NAK가 있는 경우
프레임이 변형 됐지만 프레임을 제대로 수신한 경우에 처리하는 방식은 두 가지이다. 첫 번째 방식은 프레임을 무시하는 것으로, 이는 프레임 분실 오류와 동일한 결과를 가져오기 때문에 분실 처리에 따른 타임아웃 기능을 거친다.
두 번째 방식은 NAk 프레임을 이용해 프레임 변형 사실을 송신 호스트에 통보하는 것이다. 이 방식에는 프레임 변형 오류와 프레임 분실 오류를 명확히 구분해 처리한다.

결과적으로 프레임이 변형 되었을 때나 프레임이 분실 되었을 때 송신 호스트의 재전송 기능으로 오류 복구가 이루어진다.

#### (2) 슬라이딩 윈도우 프로토콜
실제 통신 환경에서는 단방향이 아닌 양방향에서 이루어진다. **슬라이딩 윈도우 프로토콜**은 두 호스트 간의 프레임 전송을 위한 일반적인 통신 프로토콜로, 오류 제어와 함께 흐름 제어 기능을 제공한다. 슬라이딩 윈도우 프로토콜은 다음과 같은 절차를 따른다.
- 정보 프레임을 전송한느 송신 호스트는 보내려는 데이터뿐 아니라 프레임의 순서 번호, 오류 검출 코드 등을 프레임에 표기한 후 정해진 순서 번호에 따라 순차적으로 송신한다.
- 정보 프레임을 ㅂ다은 수신 호스트는 해당 프레임의 순서 번호에 근거하여 송신 호스트에 응답 프레임을 회신해야 한다. 일반적으로 응답 프레임의 순서번호는 다음에 수신하기를 기대하는 프레임의 번호를 표기한다. 따라서 긍장 응답 프레임에 기록된 순서 번호 이전까지의 프레임은 모두 제대로 수신했다는 의미가 된다.
- 송신 호스트는 `송신한 정보 프레임을 자신의 내부 버퍼에 유지`해야 하며, 이를 **송신 윈도우**라 한다. 송신 윈도우에 대기하는 정보 프레임은 송신 호스트가 수신 호스트에 프레임 전송을 완료했지만 아직 수신 호스트로부터 긍정 응답을 받지 못 한 프레임이다.
- 수신 호스트는 수신한 정보 프레임을 보관하기 위해 내부 버퍼인 **수신 윈도우**를 유지할 수 있다. 수신 윈도우에는 수신을 기대하는 프레임의 순서 번호가 들어가기 때문에 프로토콜의 동작 방식에 따라 크기가 달라질 수 있다.

##### (1) 흐름 제어
슬라이딩 윈도우 프로토콜에서 슬라이딩 윈도우는 `윈도우의 이동`을 의미하며, 이는 흐름 제어 기능을 상징적으로 대변한다. 수신 호스트가 연속으로 수신할 수 있는 정보 프레임의 개수를 윈도우의 크기로 지정함으로써, 송신 호스트의 프레임 전송 속도를 제어한다.

###### (1) 순서 번호
정보 프레임의 내용에는 프레임별로 고유하게 부여되는 순서 번호라는 일련번호가 부여된다. 이 번호는 0붙터 임의의 최대값까지 정의 되는데, 최대값 이후에는 다시 0번으로 되돌아오는 순환 방식으로 할당된다. 이런 원칙에 위배되지 않으려면 기본적으로 순서 번호의 최댓값이 송신 윈도우의 크기보다 커야 한다.

###### (2) 윈도우 크기
임의의 시점에서 `송신 호스트가 수신 호스트로부터 긍정 응답 프레임을 받지 않고도 전송할 수 있는 정보 프레임의 최대 개수`를 **윈도우 크기**라고 규정한다. 윈도우에 포함되는 정보 프레임의 관리는 순서 번호를 기반으로 이루어지는데, 이들 순서 번호의 묶음이 결과적으로 윈도우가 된다.

##### (2) 연속형 전송
정지-대기 방식의 프로토콜은 송신 윈동우의 크기가 1인 특수한 경우이다. 전송 시간이 오래 걸리는 환경에서 윈도우 크기가 1이면 전송 효율이 극단적으로 떨어진다. 이를 해결하기 위해 윈도우 크기를 늘려 `ACk 프레임을 받지 않고도 여러 정보 프레임을 연속으로 전송`할 수 있어야하는데 이러한 방식을 **연속형 전송**이라 한다. 연속형 전송 방식의 오류를 해결하는 방법에는 고백N 방식와 선택적 재전송 방식이 있다.

###### (1) 고백 N 형식
오류 복구 과정에서 `오류가 발생한 프레임을 포함해 이후에 전송된 모든 정보 프레임을 재전송 하는 방식`을 **고백 N** 방식이라 한다. 고백 N 방식은 오류가 발생한 프레임뿐 아니라, 정상적으로 수신한 프레임까지 재전송한다는 문제점이 있다. 따라서 직관적인 관점에서 보면 매우 비효율적이라고 생각될 수 있으나, 송수신 호스트 사이의 전송 지연 등에 딷라서는 효과적인 처리 방법이 될 수 있다.

###### (2) 선태적 재전송 방식
`오류가 발생한 프레임만 선택적으로 복구하는 방식`을 **선택적 재전송**이라 한다. 수신 호스트가 NAK 프레임을 전송한 후에는 프레임 처리를 완료할 때까지 다음 정보 프레임에 대한 긍정 응답 프레임을 전송하지 않도록 조심해야 한다.

고백 N 방식과 선택적 재전송 방식의 차이는 수신 윈도우의 크기 차이로 설명할 수 있다. 고백 N 방식에서는 수신 호스트가 임의의 앞선 순서 번호를 갖는 정보 프레임이 처리될 때까지 다음 정보 프레임을 모두 버린느 식으로 하면 된다. 따라서 수신 윈도우에는 현재 처리 중인 프레임 한 개만 존재하므로 수신 윈도우의 크기가 1이라 할 수 있다.
선택적 재전송 방식은 앞선 정보 프레임에 대한 처리가 이루어지지 않았어도 오류 없이 수신된 모든 정보 프레임을 수신 윈도우에 보관하기 때문에 수신 윈도웅의 크기가 송신 윈도우의 크기와 같다고 볼 수 있다. 다시 말해서 선택적 재전송 방식에서는 프레임의 도착 순서가 송신 순서와 일치하지 않을 수 있다.

##### (3) 피기배킹
`정보 프레임의 구조를 조정해 정보 프레임을 전송하면서 응답 기능까지 함께 수행`할 수 있다. 이런 방식으로 프로토콜을 작성하면 응답 프레임의 전송 횟수를 줄이는 효과가 있어 전송 효율을 높일 수 있는데, 일르 **피기배킹**이라 한다.
피기배킹을 지원하려면 정보 프레임의 구조를 확장해 전송할 데이터의 순서 번호와 현재까지 제대로 수신한 프레임의 순서 번호 두 종류의 순서 번호를 모두 표기해야 한다. 이렇게 함으로써 정보 프레임의 전송과 응답 프레임의 회신을 한 번에 처리할 수 있다.
응답 프레임을 전송할 시점에 전송할 정보 프레임이 있으면 피기배킹 기능을 사용할 수 있지만, 없으면 응답 프레임만 전송해야 한다. 그러나 현재는 정보 프레임이 없지만 잠시 후에 정보 프레임이 생길 가능성이 있으면 응답 프레임의 회신을 잠시 늦춰 피기패킹 방식으로 전송할 수 있다. 이때는 얼마나 기다리게 할 것인가가 시스템의 성능에 영향을 준다.

#### (3) HDLC 프로토콜
**HDLC** 프로토콜은 `컴퓨터가 일대일 혹은 일대다로 연결된 환경에서 데이터의 송수신 기능을 제공`한다. 데이터 통신을 위해 연결된 호스트는 주국과 종국으로 구분되고, 다시 이들은 기능을 모두 지닌 혼합국으로 정의될 수 있다. 주국에서 전송되는 메시지를 명령이라 정의하며, 이에 대한 종국의 회신을 응답이라 한다.

##### (1) 프레임 구조

![6-1. HDLC 프레임 구조]()

다음은 HDLC 프레임의 구조로 상단의 숫자는 비트 수이다. 프레임의 좌우에 위치한 01111110 플래근느 프레임의 시작과 끝을 구분한다.

- **Address**: 일대다로 연결된 환경에서 특정 호스트를 구반하여 지칭하는 목적으로 사용한다. 주국에서 정보 프레임을전송할 때는 수신 호스트의 종국 주소를 표기하며, 종국에서 전송할 때는 송신 호스트인 자신의 주소가 기록된다. 일대일 환경에서는 명령과 응답을 구분하는 용도로 사용할 수도 있다.
- **Control**: 프레임의 종류를 구분한다. 프레임의 유형에 따라 송신용 순서 번호, 회신용 순서 번호와 기타 중요한 제어 코드를 포함한다
- **Data**: 가변 크기의 전송 데이터가 포함되는데, 상위 계층인 네트워크 계층에서 보내진 패킷이 캡슐화 된다.
- **Checksum**: CRC-CCITT를 생성 다항식으로 하는 오류 검출 용도로 사용된다.

##### (2) 프레임 종류
프레임의 용도는 Control 필드 값에 따라 세 종류로 구분된다. 네트워크 계층에서 내려온 패킷을 전송하기 위한 정보 프레임, 정보 프렝미에 대한 응답 기능을 수행하는 감독 프레임, 연결 설정의 제어와 관련된 비번호 프레임으로 나뉜다.

###### (1) 정보 프레임
네트워크 계층의 데이터 전송을위해 정의된 정보 프레임은 3비트의 순서 번호를 이용한 슬라이딩 윈도우 프로토콜을 사용한다. 순서 번호는 비트 수가 3개이므로 0~7의 순서 번호 8개를 순환하여 사용한다.
- **Seq**: 정보 프레임의 송신용 순서 번호로 사용한다.
- **Next**: 피기배킹을 이용한 응답 기능으로 사용한다. 이 값은 다음에 수신을 기대하는 프레임 번호로, 이 번호 이전까지의 프레임은 모두 오류 없이 수신되었음을 의미한다.
-  **P/F**: 값이 1로 지정되었을 경우에 한하여 Poll 혹은 Final의 의미를 갖는다. 일반적으로 주국의 명령 프레임에서 사용될 때는 Poll이라 하고, 종국의 응답 프레임에서 사용될 때는 Final이라 한다. 하나의 주국 컴퓨터가 다수의 종국 컴퓨터를 제어하기 위한 용도이며, 주국에서 종국에 데이터 전송을 허가할 때 사용한다.

###### (2) 감독 프레임
**감독 프레임**은 `정보 프레임에 대한 응답 기능을 수행하는 프레임`이다. 크게 긍정 응답 프레임과 부정 응답 프레임으로 구분된다. 프레임의 세부 종류는 Type 필드 값에 따라 다음 네 가지로 구분된다.
- **Type 0(00)**: RR(Receive Ready)로 정의된 `긍정 응답 프레임`이다. 다음에 수신을 기대하는 프레임 번호를 Next 필드에 표시한다.
- **Type 1(01)**: REJ(Reject)로 정의된 `부정 응답 프레임`이다. Next 필드에는 재전송 되어야 하는 프레임의 번호를 표시한다. 따라서 송신 호스트는 Next 필드의 번호로 시작하는 프레임부터 재전송해야 한다.
- **Type 2(10)**: RNR(Receive Not Ready)로 정의된 응답 프레임으로 흐름 제어 기능까지 제공한다. Next 필드에 표시한 순서 번호는 갖는 정보 프레임의 바로 앞까지 `제대로 수신되었다는 긍정 응답 기능`과 함께 송신 호스트에 `송신을 중지하도록 요구`한다. 송신 호스트에 다시 전송을 요구할 때는 RR, REJ 혹은 기타의 제어 프레임을 사용한면 된다.
- **Type 3(11)**: SREJ(Selective Reject)로 정의된 프레임으로, `선택적 재전송 방식에서 부정 응답 기능을 지원`한다. Next 필드의 순서 번호를 갖는 특정 프레임에 대해 재전송을 요구한다.

###### (3) 비번호 프레임
비번호 프레임은 순서 번호가 없는 프레임을 정의한다. 주로 연결 제어 등의 용도로 사용하지만, 비연결형 데이터 전송을 위해 사용하기도 한다. 비번호 프레임으 Type과 Modifier 필드를 합해 총 5비트로 다음과 같은 프레임을 정의한다.
- **SABM(Set ABM)**: 비동기 균형 모드의 연결 설정을 요구한다.
- **SNRM(Set NRM)**: 정규 응답 모드의 연결 설정을 요구한다.
- **SARM(Set ARM)**: 비동기 응답 모드의 연결 설정을 요구한다.
- **DISC(Disconnect)**: 연결 설정 해제를 요구한다.
- **REST(Reset)**: 비정상적인 프로토콜의 동작에 따른 리셋 기능을 수행한다.
- **FRMR(Frame Reject)**: 비정상적인 프레임의 수신을 거부한다.
- **UA(Unnumbered ACK)**: 비번호 프레임에 대한 응답 기능을 수행한다.

세 가지 연결 모드는 다음과 같다.
- 정규 응답: 불균형 모드를 의미하기 때문에 호스트 하나는 주국으로 동작하고 다른 하나는 종국으로 동작한다. 종국에서 데이터를 전송하려면 반드시 주국의 허락을 받아야 한다.
- 비동기 균형: 두 개의 호스트가 동일한 능력을 갖는 혼합국으로 동작하며, 양쪽에서 명령과 응답을 전송할 수 있다.
- 비동기 응답: 불균형 모드이나 종국이 주국의 허락 없이도 데이털르 전송할 수 있는 권한을 갖는다.

##### (3) LAP 프로토콜

##### (4) LAPB 프로토콜