## (3) 네트워크 계층

### (1) 네트워크 계층

#### (1) IPv6 프로토콜
32비트의 주소 공간을 지원하는 현재의 IP 프로토콜은 이론상으로 최대 2^32개의 호스트를 수용할 수 있다. 인터넷이 급성장함에 따라 이 정도의 주소 크기만으로는 거의 한계점에 이른 상황이다. 호스트의 주소 공간을 대폭 확장한 **IPv6**은 기존 인터넷 환경에서 사용하는 IPv4를 대체하ㅣ 위한 차세대 프로토콜이다.

- **주소 공간 확장**: 송신 호스트와 수신 호스트의 `주소를 표시하는 공간이 32비트에서 128비트로 확장`되었다. IPv6을 이용한 인터넷 환경에서는 이론적으로 호스트를 최대2^128개까지 지원하여 무한으로 확장되는 인터넷 접속자를 모두 수용할 수 있다. 또한 개인이 무선으로 연결하는 유비쿼터스 장비가 기하급수적으로 보급되는 환경에도 쉽게 대처할 수 있다.
- **헤더 구조 단순화**: IPv4의 헤더 구조는 현재 네트워크 환경이 반영되지 못 한 이유로 매우 비효율적으로 복잡하다. 반면에 IPv6 헤더는 불필요한 필드가 제외되거나 확장 헤더 형식으로 변경되었다. 이는 `기존의 IP 프로토콜에서 과도하게 수행되는 오류 제어와 같은 오버헤드를 줄여 프로토콜의 전송 효율을 높이기 위함`이다.
- **흐름 제어 기능 지원**: `흐름 제어 기능을 지원할 수 있는 필드를 도입해 일정 범위 내에서 예측 가능한 데이터 흐름을 지원`한다. 따라서 하나의 연속 스트림으로 전송해야하는 연관 패킷의 전송 기능을 지원함으로써 실시간 기능이 필요한 멀티미디어 응용 환경을 수용할 수 있다.

##### (1) IPv6 헤더 구조
IPv6의 헤더 구조는 9개의 기본 필드를 지우너한다. 총 40바이트 중 32바이트는 주소 공간으로 할당하고, 8바이트만 프로토콜 기능을 위해 사용한다. IPv6 패킷 헤더는 기본 헤더와 확장 헤더로 나뉘며, 다음은 크기가 고정된 기본 헤더의 구조이다.

![8-1. IPv6 기본 헤더의 구조]()

IPv6 기본 헤더 뒤에 확장 헤더를 하나 이상 둘 수 있는데, **확장 헤더의 종류**는 다음과 같다.
- Hop-by-Hop Options Header
- Routing Header
- Fragment Header
- Destination Options Header
- Authentication Header
- Encapsulating Security Payload Header

**IPv6의 기본 헤더**에 속하는 필드는 다음과 같다.
###### (1) **DS/ECN**
차등 서비스를 지원하는 6비트의 DS 필드와 2비트의 ECN 필드가 정의되어있다.

###### (2) **Flow Label**
IPv4가 생성하는 패킷은 라우터가 중개할 때 동일한 기준을 적용하여 처리한다. IPv6에서는 특정 송수신 호스트 사이에 전송되는 데이터를 하나의 흐름으로 정의해 `중간 라우터가 이 패킷을  특별한 기준으로 처리할 수 있도록 지원`한다. 따라서 라우터는 이 기능을 지원하기 위해 필요한 흐름 정보를 저장하여 처리할 수 있어야 한다.
Flow Label 필드는 음성이나 영상 데이터처럼 실시간 서비스가 필요한 응용 환경에서 사용하는데, **기본 원칙**은 다음과 같다.
- Flow Label 필드를 지원하지 않는 호스트가 라우터에서는 `IPv6 패킷을 생성할 때 반드시 0으로 지정`해야 한다. 패킷의 중개 과정에서 현재 값은 그대로 유지하며, 패킷을 수신하는 측에서는 필드 값을 무시한다.
- Flow Label 필드의 값이 0 이외의 동일한 번호로 부여받은 패킷은 `다른 필드를 모두 동일하게 지정해야 한다.` 패킷을 중개하는 라우터가 다른 필드 값을 보지 않고 Flow Label 필드만으로 라우팅 등을 간단히 처리하도록 위함이다.
- Flow Label 값은 최대 범위 `내에서 랜덤하게 선택`된다. 단, 현재의 전송 흐름에서는 `동일 번호가 부여되지 않도록 해야 한다.`

###### (3) 기타 필드
- **Version Number**: IP 프로토콜 버전 번호이며, Ipv4와 구분하기 위해 지정된다.
- **Payload Length**: 헤더를 제외한 패킷의 크기로, 단위는 바이트이다.
- **Next Header**: 기본 헤더 다음에 이어지는 헤더의 유형을 수신 호스트에 알려 준다.
- **Hop Limit**: IPv4의 Time To Live 필드와 동일한 역할을 수행한다.
- **Source Address/Destination Address**: 송수신 호스트의 IP 주소를 나타낸다.

##### (2) IPv6 주소
> FFFF:FFFF: ... :FFFF 

IPv6에서는 `16비트의 숫자 8개를 콜론으로 구분하여 표시`한다. (예 D1D1:1111:3F3F:1700:4545:1212:1111:1231) 이처럼 IPv6 주소는 아주 커 일일이 표기하기 불편하므로 축약해 표시하는 방안도 만들어지고 있다. IPv4와 함께 사용하는 환경에서 IPv4 주소를 캡슐화하여 다음과 같이 표현하기도 한다.
> X:X:X:X:X:X:d.d.d.d

X:X:X:X:X:X에서 X는 16비트이므로 총 96비트이고, d.d.d.d에서 d는 8비트이므로 총 32비트이다. 따라서 전체 크기는 IPv6의 주소 크기와 동일한 128비트이다.

#### (2) 이동 IP 프로토콜
현재 진행되는 인터넷 환경 변화와 관련해 가장 많이 연구되는 분야 중 하나는 이동하는 사용자가 서비스 중단 없이 인터넷에 접속할 수 있는 이동 환경 서비스를 수용하는 문제이다.

##### (1) 터널링 원리
이동 호스트가 자신의 고유 주소를 유지하면서 인터넷 서비스를 받으려면 계속 이동하는 송수신 호스트 간의 데이터 라우팅 처리가 가장 중요하다.

###### (1) 상이한 전송 수단
**이동 IP** 프로토콜을 이해하려면 먼저 **터널링** 원리를 알아야 한다. 터널링 원리를 이해하기 위해 사람이 육지와 섬을 거쳐 이동하는 경우를 예를 들어 보자.

![8-2. Ip 터널링의 원리]()

좌측 그림에서 홍길동이라는 사람이 육지 a 지점에서 출발하여 섬에 있는 목적지 d에 도착하려면 중간에 있는 b와 c를 거쳐야 한다. 이동할 때 육지에서는 버스를 이용하고, 바다에서는 배를 이용한다. 이때 버스와 배는 모두 네트워크 계층을 지원하는 IP 프로토콜이라 볼 수 있으며, 버스와 배에 실려서 이동하는 홍길동은 IP 프로토콜의 전송 데이터가 된다. 여기서 문제는 출발지 a에서 목적지 d에 도착하는 동안 버스라는 IP 프로토콜에서 배라는 IP 프로토콜로 갈아타야 한다는 것이다. 즉, `사용자가 스스로 IP 프로토콜을 교체하는 작업이 이루어져야 한다.`

###### (2) 터널링 방식
IP 프로토콜을 교체하는 방식보다 문제를 간단히 해결하는 방법은 우측 그림과 같이 터널링 기능을 이용하는 것이다. 터널링 방식을 사용하면 홍길동이 출발지에서 목적지까지 버스만 이용하므로 `네트워크 최종 사용자는 IP 프로토콜의 교체 과정에 개입하지 않는다.` 그렇기 때문에 `외부의 프로토콜을 이해하지 못 해도 문제되지 않는다.`

##### (2) IP 터널링
IP 터널링은 **주소 표현**이 필요하다. 통신할 상대방을 구분하기 위한 주소가 필요한 것이다. 이동망 환경에서 주소를 처리하는데 이동한 위치에서 `새로운 IP 주소를 할당하는 것`과 `호스트 고유의 주소를 유지하는 작업`을 수행해야 한다.

![8-3. 이동 IP 프로토콜의 기본 동작 원리]()

IP 주소가 이동망 환경에서 들어오게 되면 IP 주소를 추적할 수 있는 기능이 필요하게 된다. 그래서 에이전트를 사용하게 된다. 두 종류의 주소를 사용하게 되는데 **Home Address**는 `이동 호스트를 위한 고정 주소`를 나타낸다. **홈 에이전트**는 `이동 호스트를 위한 고정 위치(고정 주소)에서 포린 에이전트로의 연결을 처리`한다. **COA**는 `이동 호스트를 위한 가변 주소`로 일시적으로 할당된다. **포린 에이전트**는 이동 호스트에서 근접한 에이전트로 `이동 호스트의 위치가 바뀌면 새로운 위치를 관장하여 COA를 부여`한다. 호스트는 이동할 때마다 새로운 COA를 할당받고 기존 COA를 회수하는 과정을 반복한다. 따라서 포린 에이전트 주소가 계속 변함으로 터널을 형성하여 이동 호스트가 정보를 주고받을 수 있는 환경을 조성한다.

임의의 송신 호스트에서 이동 호스트까지 패킷이 전달되는 과정을 보면 먼저 송신 호스트가 이동 호스트를 목적지 주소로 표기하여 패킷을 전송한다. 이 패킷은 홈 에이전트로 전달되는데 홈 에이전트는 이동 호스트를 관장하는 포린 에이전트와 설정된 터널을 이용해 패킷을 중개하고 포린 에이전트가 패킷을 다시 이동 호스트에 전달함으로써 데이터 전송이 완료된다.

IP 터널은 IP 캡슐링 방식으로 패킷을 중개한다. IP 캡슐 패킷을 터널 구간에서 원래의 패킷을 그대로 데이터로 생각하여 IP 헤더를 추가적으로 붙이는 작업을 한다. 추가된 헤더의 목적지에 COA가 들어가게 된다.

##### (3) 기타 네트워크 계층 프로토콜
IP 프로토콜은 응용 계층에서 생성된 사용자 데이터를 전송하기 위해 사용된다. 인터넷 환경에서 데이터 전송 과정이 올바르게 이루어지려면 전송 프로토콜 외에도 다양한 제어 프로토콜이 필요하다.

##### (1) ARP 프로토콜
네트워크 환경에서 임의의 호스트가 다른 호스트에 데이터를 전송하려면 수신 호스트의 IP 주소 뿐 아니라, MAC 주소도 알아야 한다. 수신 호스트의 IP 주소는 보통 응용 프로그램 사용자가 프로그램을 실행하는 과정에서 직접 입력하므로, IP 주소로부터 수신 호스트의 MAC 주소를 얻는 작업이 추가로 필요하다.

###### (1) MAC 주소
IP 프로토콜 헤더에서 필요한 송수신 IP 주소와 함께 MAC 주소가 필요하다. 송신 호스트의 IP 주소는 자신의 팔일 시스템에 보관되므로 쉽게 구할 수 있다. 또한 수신 호스트의 IP 주소는 일반적으로 사용자가 도메인 이름을 입력하는데, 도메인 이름은 DNS 서비스를 통해 IP 주소로 쉽게 변환할 수 있다.

MAC 주소의 경우를 살펴보면 송신 호스트의 MAC 주소는 자신의 LAN 카드에 내장되므로 이 값을 읽으면 된다. 문제는 수신 호스트의 MAC 주소이다. 송신 호스트의 내부 정보로는 수신 호스트의 MAC 주소를 얻을 수 없다. 따라서 `수신 호스트의 IP 주소를 매개변수로 하여 수신 호스트의 MAC 주소 값을 받는` **ARP** 기능을 이용한다.

예를 들어, 호스트가 ARP request라는 특수 패킷을 브로드 캐스팅 한다. ARP request 패킷을 네트워크의 모든 호스트가 수신하지만, 관계없는 호스트들은 패킷을 무시하고, 패킷의 IP 주소가 자신의 IP 주소와 동일한 호스트만 ARP reply 패킷을 사용해 자신의 MAC 주소를 호스트에 회신한다. `패킷을 수신한 모든 호스트는 수신 호스트의 IP 주소와 MAC 주소 매핑 값을 자동으로 얻을 수 있다.` 이와 같은 방식으로 ARP 트래픽에 의한 **네트워크 과부하를 최소화** 한다.

###### (2) RARP 프로토콜의 필요성
**RARP**는 ARP와 반대로 `MAC 주소를 이용해 IP 주소를 제공`한다. `디스크가 존재하지 않는 시스템`이나 X윈도우 터미널 등에서는 파일 시스템이 없으므로 IP 주소를 보관할 방법이 없다. 이런 경우 자신의 MAC 주소와 IP 주소의 매핑 값을 보관하는 서버 호스트로부터 IP 주소를 얻어야 하기 때문에 RARP를 사용한다.

##### (2) ICMP 프로토콜
**ICMP**는 `인터넷 환경에서 오류에 관한 처리를 지원`한다. IP 프로토콜은 데이터 전송 과정에서 패킷 폐기 등의 오류가 발생해도 이를 보고하는 기능이 없다. 따라서 이를 대체 지원하기 위해 네트워크 계층 프로토콜인 ICMP는 오류가 발생한 IP 패킷에 대하여 그 원인을 송신 호스트에 전달한다. TCP/IP 기반의 통신망에서 전송 과정에 문제가 발생하면 라우터에 의해 ICMP 메시지가 자동으로 발생한다.

###### (1) ICMP 메시지
ICMP에 의해 발생하는 메시지의 종류는 Type 필드 값에 따라 구분되며, 크게 오류 보고 메시지와 질의 메시지로 나뉜다.

**오류 보고 메시지**는 `IP 패킷을 전송하는 과정에서 발생하는 문제를 보고`하는 것이 목적이며, IP 패킷을 전송한 송신 호스트에 전달된다. ICMP는 단순히 오류 발생 사실을 통보하는 것이므로 오류를 해결하는 것은 상위 계층의 몫이다. 주요한 오류 보고 메시지는 다음과 같다.
- DESTINATION UNREACHABLE
- SOURCE QUENCH
- TIME EXCEEDED

**질의 메시지** 는 라우터 혹은 다른 호스트들의 정보를 획득하려는 목적으로 사용되며 다음과 같다.
- ECHO REQUEST, ECHO REPLY
- TIMESTAMP REQUEST, TIMESTAMP REPLY

###### (2) ICMP 헤더 형식
다음은 **오류 보고 메시지의 구조**를 보여준다.

![8-4. ICMP 메시지: 오류 보고 메시지]()

- **Type**: 1바이트의 크기로 메시지의 종류를 구분한다. Type + Code 필드로 메시지를 구분한다.
- **Code**: 메시지 내용에 대한 자세한 정보를 제공하는 매개변수 값이다.
- **Checksum**: ICMP 전체 메시지에 대한 체크섬 기능을 지원한다.

다음은 **질의 메시지의 구조**를 보여준다.

![8-5. ICMP 메시지: 질의 메시지]()
identifier와 Squence Number 필드를 사용하여 메시지를 구분하는 기능이 사용된다.

###### (3) ICMP 메시지 전송
ICMP는 기능적으로 IP 프로토콜과 가튼 네트워크 계층의 역할을 수행한다. 그러나 ICMP 메시지는 데이터 링크 계층에 바로 전달되지 않고, IP 패킷에 캡슐화 된 후 전달된다. 즉, ICMP 메시지는 IP 프로토콜의 데이터로 처리되므로 IP 헤더에 캡슐화되어 계층 2 프로토콜로 전달된다.


<br>

###### 참고 자료
[ITstory](https://copycode.tistory.com/90)