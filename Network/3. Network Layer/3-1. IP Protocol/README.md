## (3) 네트워크 계층

### (1) IP 프로토콜

#### (1) 네트워크 계층의 기능
네트워크 계층에서 제공하는 주요 기능을 정리하면 다음과 같다.
- **라우팅**: `송수신 호스트 사이의 패킷 전달 경로를 선택하는 과정`을 라우팅이라 한다. 네트워크 구성 형태에 대한 정보는 **라우팅 테이블**이라는 기억 장소에 저장된다. 이 정보를 이용해 패킷이 목적지까지 도달하기 위한 경로를 선택한다. 라우팅 테이블 정보는 네트워크 관리자나 네트워크 자신의 판단에 의해 계속 변경될 수 있다.
- **혼잡 제어**: `네트워크에 패킷 수가 과도하게 증가하는 현상`을 **혼잡**이라 하고, 혼잡 현상을 예방하거나 제거하는 기능을 **혼잡 제어**라 한다. 혼잡이 발생하면 네트워크 전체의 전송 속도가 급격히 떨어지므로 혼잡이 발생하지 않도록 관리해야 한다. 특히 네트워크의 특정 지역에서 혼잡이 발생하면, 혼잡의 특성상 주위로 빠르게 확산될 가능성이 높다.
- **패킷의 분할과 병합**: 전송 계층에서 보낸 데이터가 너무 크면 여러 개의 패킷으로 작게 쪼개 전송해야 한다. 이와 같이 `큰 데이터를 여러 패킷으로 나누는 과정`을 **분할**이라 하고, 반대로 `목적지에서 분할된 패킷을 다시 모으는 과정`을 **병합**이라 한다. 패킷의 분할과 병합 과정이 양 끝단 시스템 사이에서 이루어지는 경우라면 전송 계층이 동작하는 종단 수신 시스템에 분할된 패킷을 보내고, 네트워크 계층에서 이루어지는 경우라면 중간의 각 라우터에서 분할과 병합을 반복한다.

##### (1) 연결형 서비스와 비연결형 서비스
- **비연결형 서비스**: 패킷의 전달 순서, 패킷 분실 여부 등에서 연결형 서비스보다 `신뢰성이 떨어지는` 전송 방식이다. 따라서 전송 계층에서 네트워크 계층의 비연결형 서비스를 이용할 때는 연결형 서비스를 이용하는 경우보다 `자체적으로 오류 제어와 흐름 제어 기능을 더 많이 수행해야 한다.`
    비연결형 서비스를 이용해 패킷을 전송하면 패킷이 `서로 다른 경로를 통해 목적지 호스트로 전달`되기 때문에 패킷이 `도착하는 순서가 일정하지 않을 수 있다.` 따라서 상위 계층인 전송 계층은 수신한 패킷의 순서를 재조정하는 기능이 필요하다.
    인터넷 환경에서 네트워크 계층의 기능을 지원하는 **IP 프로토콜**은 비연결형 서비스의 대표적인 예이다. IP 프로토콜 위에서 동작하는 전송 계층 프로토콜인 TCP는 연결형 서비스를 지원하고, 또 다른 전송 계층 프로토콜인 UDP는 비연결형 서비스를 제공한다.
- **연결형 서비스**: 상대적으로 `신뢰성이 높은 서비스`로, `패킷을 전송하기 전에 연결을 미리 설정`하여 송신하는 방식이다. 비연결형 서비스와 달리 전달되는 패킷들이 모두 동일한 경로를 이용하기 때문에 목적지에 도착하는 패킷의 순서가 송신된 순서와 동일하다는 특성이 있다.

##### (2) 라우팅

###### (1) 정적 라우팅과 동적 라우팅
네트워크 구성의 변화에 효과적으로 대처할 수 있는 신뢰성 확보도 라우팅 경로 선택 시 중요하게 고려할 사항이다. 라우팅 경로는 정적 라우팅이나 동적 라우팅 방식으로 선택한다.
- **정적 라우팅**: 호스트 사이에서 `패킷 전송이 이루어지기 전에 경로 정보를 라우터에 미리 저장`하여 중개하는 방식이다. 패킷을 중개하기 위한 최적의 경로 정보는 라우터별로 저장하여 관리하는데, 운용 중인 `네트워크의 구성에 변화가 생기면 이에 적절한 대처를 할 수가 없다`는 문제점이 있다. 라우터에 보관된 경로 정보가 고정되어 변화된 정보를 갱신하기 쉽지 않으며, 네트워크 내부의 혼잡도를 반영할 수 없다는 단점이 있다.
- **동적 라우팅**: 라우터에서 사용하는 `경로 정보를 네트워크 상황에 따라 적절하게 변경하는 방식`으로, 경로 정보의 변경 주기에 따라 계속 보완할 수 있다. 따라서 현재 `네트워크 상황을 고려해 최적의 경로 정보를 선택`할 수 있지만, 경로 정보를 수집하고 관리하는 등의 복잡한 작업이 추가로 필요하다. 이는 `네트워크에 새로운 부하를 가해 성능에 부정적인 영향`을 미친다.

###### (2) HELLO/ECHO 패킷
라우터의 초기화 과정에서 가장 먼저 할 일은 이웃 라우터의 경로 정보를 파악하는 것이다. 각 라우터는 이웃에 연결된 라우터에 초기화를 위한 **HELLO 패킷**을 전송해 경로 정보를 얻는다. 라우터 사이의 전송 지연 시간을 측정하기 위해서 **ECHO 패킷**을 전송하는데, ECHO 패킷을 수신한 호스트는 송신 호스트에 즉각 회신하도록 설계되어 있다. 이런 과정을 반복하고, 측정값의 평균을 구해 해당 라우터까지의 전송 지연 시간을 유추할 수 있다. 지연 시간을 측정하는 과정에서 측정 시점의 네트워크 트래픽 정도에 따라 결과가 달라질 수 있기 때문에 측정 오차의 차이를 어떻게 해석할 지는 신중히 판단해야 한다.

###### (3) 라우팅 테이블
패킷 전송 과정에서 라우터들이 적절한 경로를 쉽게 찾도록 하기 위한 가장 기본적인 도구로 라우팅 테이블을 사용한다. 라우팅 테이블에 포함해야 하는 필수 정보는 목적지 호스트, 다음 홉이다. **목적지 호스트**에는 `패킷의 최종 목적지가 되는 호스트의 주소 값`을 지정한다. **다음 홉**에는 목적지까지 패킷을 전달하기 위한 이웃 라우터를 지정한다. `목적지까지 도달하는 여러 경로 중에서 효과적인 라우팅을 지원하는 경로`가 있을 수 있는데 이 경로에서 다음 홉에 위치한 라우터의 주소를 기록한다.

###### (4) 라우팅 정보의 처리
라우팅을 효과적으로 수행하려면 라우팅 정보가 네트워크의 현재 상황을 정확히 반영할 수 있도록 관리해야 한다. 라우팅 정보 관리와 관련된 처리 방법에는 소스 라우팅, 분산 라우팅, 중앙 라투이, 계층 라우팅 등이 있다.
- **소스 라우팅**: `패킷을 전송하는 호스트가 목적지 호스트까지 전달 경로를 스스로 결정하는 방식`을 소스 라우팅이라 한다. 소스 라우팅을 지원하려면 송신 호스트의 라우팅 테이블에서 패킷을 수신 호스트까지 전달하기 위한 경로 정보를 관리해야 하며, 이러한 `경로 정보를 전송 패킷에 기록`해야 한다. 소스 라우팅 방식은 `모든 라우팅 정보를 송신 호스트가 관리하므로 중간에 있는 라우터들은 라우팅 테이블을 따로 관리할 필요가 없다.` 
  소스 라우팅은 데이터 그램과 가상 회선 방식에서 모두 이용할 수 있다. **가상 회선 방식**에서는 연결의 초기화 과정에서 경로 정보를 담은 특수 연결 패킷을 사용한다. `중간 라우터는 패킷의 경로 정보를 해석함으로써 전달 경로를 선택`할 수 있다. **데이터그램 방식**에서는 전송되는 모든 패킷의 헤더에 경로 정보가 들어가므로 일반적인 데이터그램 방식에 비하여 `신뢰성을 향상`시킬 수 있다.
- **분산 라우팅**: `라우팅 정보가 분산`되는 방식으로 패킷의 전송 경로에 위치한 `각 라우터가 효율적인 경로 선택에 참여`한다. 분산 라우팅은 **데이터그램 방식**에서 많이 사용한다. 이 방식의 장점은 네트워크에 존재하는 호스트의 수가 많아질수록 다른 방식보다 효과적일 수 있다는 것이다. 라우터가 관리하는 경로 정보는 다음 경로를 선택하기 위한 내용을 포함하는데, `네트워크 상황에 따라 적절히 변경하는 동적 특징`이 있다.
- **중앙 라우팅**: **RCC**라는 `특별한 호스트를 사용해 전송 경로에 관한 모든 정보를 관리하는 방식`이다. 패킷 전송을 원하는 송신 호스트는 반드시 RCC로부터 목적지 호스트까지 도착하기 위한 경로 정보를 미리 얻어야 한다. 이 정보를 이용해 송신 호스트는 소스 라우팅과 동일한 원리로 패킷을 전송한다.
  중앙 라우팅의 장점은 경로 정보를 특정 호스트가 관리하기 때문에 다른 `일반 호스트가 경로 정보를 관리하는 부담을 줄일 수 있다`는 것이다. 그러나 네트워크의 규모가 커짐에 따라 `RCC에 과중한 트래픽을 주어 전체 효율이 떨어질 수 있다`는 단점이 있다.
- **계층 라우팅**: 계층 라우팅은 분산 라우팅 기능과 중앙 라우팅 기능을 적절히 조합하는 방식으로, 전체 네트워크 구성을 계층 구조 형태로 관리한다. 일반적으로 네트워크 규모가 계속 커지는 환경에 효과적이다.

##### (3) 혼잡 제어
**흐름 제어**는 송신 호스트와 수신 호스트 사이의 `논리적인 점재점 전송 속도`를 다룬다. 반면, **혼잡 제어**는 더 넓은 관점에서 `호스트와 라우터를 포함한 서브넷에서 네트워크의 전송 능력 문제를 다룬다.`

###### (1) 혼잡의 원인
혼잡이 발생하는 주원인은 전송 시간 초과에 의한 타임아웃 기능을 통해 패킷이 재전송되는 데 있다. 네트워크의 처리 능력보다 지나치게 많은 패킷이 입력되면, 내부 버퍼 용량이 부족해진다. 내부 버퍼 용량 부족이 심화되어 더 이상 패킷을 보관할 수 없게 되면, 전송 패킷이 버려진다. 전송 패킷이 버려지면 송신 호스트는 타임아웃 동작을 통해 패킷을 재전송하므로 네트워크로 송신되는 패킷의 양이 점점 늘어 혼잡이 발생하게 된다.

###### (2) 트래픽 성형
혼잡은 트래픽이 특정 시간에 집중되는 버스트 현상에서 기인되는 경우가 많다. 따라서 송신 호스트가 전송하는 `패킷의 발생 빈도가 네트워크에서 예측할 수 있는 전송률로 이루어지게 하는 기능`이 필요한데, 이를 **트래픽 성형**이라 한다.
송신 호스트는 사전에 네트워크와 협상하여 네트워크로 유입되는 패킷의 특성을 조율할 수 있다. 협상을 통해 네트워크로 유입되는 패킷의 분포 특성을 미리 정해두면 네트워크에서는 전체 트래픽의 혼잡도를 예측하여 혼잡 제어를 효율적으로 수행할 수 있다.
이와 같은 트래픽 성형과 관련된 알고리즘 중 유명한 것이 **리키 버킷**이다. 리키 버킷 알고리즘은 소인 호스트와 네트워크 사이에는 송신 호스트가 협상에서 제시한 전송 특성을 반영하는 적절한 크기의 깔때기가 위치한다. 깔때기의 출구 크기는 협상 결과를 의미하므로 크기가 고정되어 있다. 따라서 송신 호스트가 협상 값보다 많은 양의 패킷을 전송해도 깔때기 크기 이상의 패킷이 네트워크에 유입될 수 없다. 과도하게 입력된 패킷은 깔때기의 부피 범위 내에서 내부 버퍼에 임시 저장된다. 깔때기에 저장할 수 있는 패킷의 양은 일정하며, 한계치를 초과하면 패킷이 넘쳐 패킷 분실 오류가 발생한다.
리키 버킷 알고리즘을 사용하면 송신 호스트로부터 입력되는 패킷이 시간대별로 일정하지 않아도 깔때기를 통과하면서 일정한 전송률로 변경된다.

###### (3) 혼잡 제거
가상 회선 방식을 사용하는 서브넷에서 혼잡을 감지했을 때 이를 완화하는 가장 간단한 방법 중 하나는 혼잡이 사라질 때까지 연결 설정을 허락하지 않는 것이다. 그러나 실제 네트워크에서 전체보다 일부 지점에서 혼잡이 발생하는 경우가 많다. 따라서 특정 지역에 혼잡이 발생하면 패킷의 전송 경로를 적절히 조정해줌으로써 혼잡이 발생한 곳을 거치지 않도록 가상 회선 연결을 설정하는 방안이 필요하다.
혼잡을 처리하는 또 다른 방식은 호스트와 서브넷이 가상 회선 연결 과정에서 협상하는 것이다. 즉, 전송 과정에서 사용하는 대역을 미리 할당받음으로써, 네트워크에서 수용 불가능한 정도로 트래픽이 발생하는 일을 사전에 예방하는 것이다. 이 방식의 문제점은 개별 연결이 예약한 전송 대역을 해당 사용자가 이용하지 않더라도 다른 사용자가 이용하지 못한다는 점이다. 따라서 이러한 **자원 예약 방식**은 통신 자원을 낭비할 염려가 있다.

#### (2) 라우팅 프로토콜

##### (1) 간단한 라우팅 프로토콜
네트워크에서 의미하는 거리의 기준은 다양하지만, 라우팅과 관련해 가장 보편적으로 이용하는 기준은 전송 경로의 중간에 위치하는 라우터의 개수, 즉 **홉**의 수로 판단하는 것이다.

###### (1) 최단 경로 라우팅
최단 경로 라우팅 방식은 패킷이 목적지에 도달할 때까지 거치는 라우터의 수가 최소화될 수 있도록 경로를 선택한다. 장점은 비교적 간단한 형식으로 쉽게 적용할 수 있다는 거인데, `전송 패킷이 목적지까지 도착하는 여러 경로 중 가장 짧은 경로를 선택`한다. 거리 기준이 될 수 있는 요소에는 홉, 패킷의 전송 지연 시간, 전송 대역폭, 통신 비용 등이 있다.

###### (2) 플러딩
**플러딩**은 `라우터가 자신에게 입력된 패킷을 출력 가능한 모든 경로로 중개하는 방식`이다. 이 방식ㅇ세ㅓ는 원본 패킷과 동일한 패킷이 무수히 생성되고, 모든 경로를 통해 반복하여 전송하므로 네트워크에 패킷이 무한 개 만들어질 수 있다. 패킷이 무한정 증가하는 현상을 방지하려면 각 패킷의 홉 수를 일정 범위로 제한해 라우터에서 이를 확인하여 제거해야 한다. 플러딩 방식의 라우팅은 중요한 데이터를 모든 호스트에 동시에 전달하는 환경에서 제한적으로 사용한다.

##### (2) 거리 벡터 라우팅 프로토콜
거리 벡터 라우팅 프로토콜은 `라우터가 자신과 직접 연결된 이웃 라우터와 라우팅 정보를 교환하는 방식`이다. 정보를 교환하는 라우터는 거리 벡터 프로토콜을 사용하는 호스트나 라우터들이다. 교환 정보는 각각의 라우터에서 전체 네트워크에 소속되는 개별 네트워크까지 패킷을 전송하는 데 걸리는 거리 정보이다.
거리 벡터 알고리즘을 구현하려면 라우터가 다음 세 가지 필수 정보를 관리해야 한다.

###### (1) 링크 벡터
**링크 벡터**는 `라우터와 직접 연결된 이웃 네트워크에 대한 연결 정보를 보관`한다. 링크 벡터에 보관된 정보는 라우터가 해당 네트워크와 연결하기 위해 할당한 라우터 포트 번호라고 생각할 수 있다. 라우터와 직접 연결된 네트워크가 M개일 때 링크 벡터 정보는 다음과 같이 나타낸다.
> 링크 벡터 L(x) = [포트(1), 포트(2), ...]

###### (2) 거리 벡터
**거리 벡터**는 전체 네트워크에 소속된 `개별 네트워크들까지의 거리 정보를 관리`한다. 거리 벡터에서 관리하는 정보는 일반적으로 개별 네트워크까지 패킷을 전송하는 데 걸리는 최소 전송 지연 시간이다. 네트워크가 N개라고 가정하면 거리 벡터 정보는 다음과 같이 나타낸다.
> 거리 벡터 D(x) = [거리(1), 거리(2), ...]

###### (3) 다음 홉 벡터
다음 홉 벡터는 개별 네트워크까지 `패킷을 전송하는 경로에 있는 다음 홉 정보를 관리`한다. 보관하는 정보의 수는 전체 네트워크에 속한 네트워크의 개수로, 거리 벡터의 경우와 같다.
> 다음 홉 벡터 H(x) = [홉(1), 홉(2), ...]

###### (4) RIP 프로토콜
**RIP**는 거리 벡터 방식을 사용하는 내부 라우팅 프로토콜 중에서 가장 간단하게 구현된 것이다. 소규모 네트워크 환경에 적합하며, 현재 가장 많이 사용하는 라우팅 프로토콜 중 하나이다.
RIP가 제대로 동작하려면 이웃 라우터가 제공하는 거리 벡터 정보가 임의의 짧은 시간 내에 모두 도착해야 한다. 하지만 현실적으로 구현이 쉽지 않다. 특히 RIP 패킷은 UDP 프로토콜을 사용하는데, UDP는 비신뢰성 전송을 제공하므로 RIP 패킷이 전송 과정에서 사라질 수도 있다. 이런 이유 때문에 RIP는 다음과 같은 제한을 두어 개별 거리 정보가 라우팅 테이블에 순차적으로 적용되도록 한다.
- 입력되는 거리 벡터 정보가 새로운 네트워크의 목적지 주소이면 라우팅 테이블에 적용한다.
- 입력되는 거리 벡터 정보가 기존 정보와 비교하여 목적지까지 도착하는 지연이 더 적으면 대체한다.
- 임의의 라우터로부터 거리 벡터 정보가 들어왔을 때, 라우팅 테이블에 해당 라우터를 다음 홉으로 하는 등록 정보가 있으면 새로운 정보로 수정한다.

RIP는 라우터 사이에서 링크 벡터, 거리 벡터, 다음 홉 벡터 등의 정보를 교환하기 위해 다음과 같은 패킷 구조를 사용한다.

![7-1. RIP 패킷의 구조]()

##### (3) 링크 상태 라우팅 프로토콜
**링크 상태 라우팅 프로토콜**은 `개별 라우터가 이웃 라우터까지의 거리 정보를 구한 후, 이를 네트워크에 연결된 모든 라우터에 통보한다.`
거리 벡터 라우팅 프로토콜에서는 각 라우터가 상당한 양의 정보 전송을 요구받고, 특히 링크 상태가 많이 변하면 동작 과정에서 시간이 많이 소요될 수 있다. 링크 상태 알고리즘은 이와 같은 단점을 극복하려 고안된 방식이다.
거리 벡터 라우팅 프로토콜 알고리즘의 특성상 정보가 주기적으로 전달되지만 링크 상태 라우팅 프로토콜에서는 `이웃 라우터와 연결된 상황에 변화가 있을 때만 정보 전달`이 이루어진다. 링크 상태 라우팅 프로토콜은 정보 전달을 위해 **플러딩** 기법을 사용한다. 이때 정보가 입력된 선로를 통해 출력되지 않도록 주의해야 한다.
링크 상태 방식을 사용하는 라우팅 프로토콜에는 TCP/IP 기반의 인터넷에서 사용하는 **PSPF**가 있다.

##### (4) 외부 라우팅 프로토콜
외부 라우팅 프로토콜에서 사용하는 경로 벡터 프로토콜은 경로에 관한 거리 정보 값이 필요 없는 방식이다. 단순히 해당 `라우터에서 어느 네트워크가 연결 가능한지에 대한 정보들만 제공`한다. 이는 원거리의 경로 정보를 관리하는 외부 라우팅 프로토콜은 경로의 존재 유무에 초점을 맞추기 때문이다.
**BGP**는 외부 라우팅 프로토콜로, 인터넷에서 많이 사용된다. BGP는 서로 다른 종류의 자율 시스템에서 동작하는 라우터가 라우팅 정보를 교환할 수 있도록 해준다. 이와 같이 종류가 `다른 환경에서 동작하는 라우터`를 일반적으로 **게이트웨이**라 한다. BGP는 TCP 프로토콜을 이용해 메시지를 교환한다.

#### (3) IP 프로토콜
인터넷 환경에서 네트워크 계층의 데이터 전송 프로토콜로 이용되는 **IP**는 호스트 주소 표기, 패킷 분할에 관한 기능은 지원하지만, 단대단 형식의 오류 제어나 흐름 제어 기능은 제공하지 않는다. IP 프로토콜에서 라우터 간의 패킷을 중개할 때는 Best Effort라는 원칙에 따라 전송하는데, 이 방식은 전송 패킷이 수신 호스트에 100% 도착하는 것을 보장하지 않는다. 따라서 IP 프로토콜에서 제공하지 않는 전송 오류 문제를 상위 계층에서 고려해야 한다. IP 프로토콜의 주요 특징은 다음과 같다.
- **비연결형 서비스를 제공한다.**
- **패킷을 분할/병합하는 기능을 수행하기도 한다.**
- **데이터 체크섬은 제공하지 않고, 헤더 체크섬만 제공한다.**
- **Best Effort 원칙에 따른 전송 기능을 제공한다.**

##### (1) IP 헤더 구조

![7-2. IP 헤더의 구조]()

###### (1) DS/ECN
DS와 ECN 필드가 도입되기 전에는 8비트의 Service Type 필드로 정의되어 우선순위, 지연, 전송률, 신뢰성 등의 값을 지정할 수 있었다. **Service Type** 필드는 `IP 프로토콜이 사용자에게 제공하는 서비스의 품질에 관련된 내용을 표현`하며, 각 비트의 내용은 다음과 같다.

![7-3. Service Type]() 

차등 서비스 개념이 도입되면서 Service Type 필드는 6비트의 DS 필드와 2비트의 ECN 필드로 새로 정의되었다. 이는 인터넷에서 다양한 트래픽 요구 조건을 필요로 하는 서비스들에 대하여 서로 다른 수준의 QoS를 지원하기 위함이다.
**DS** 필드 값은 `차등 서비스의 기준이 되는 레이블 값으로 64개의 트래픽 클래스를 정의`할 수 있다. DS를 사용하기 위해 사전에 서비스 제공자와 서비스 이용자 사이에 서비스 등급에 대한 합의가 이루어지며, 동일한 DS 값을 갖는 트래픽들은 동일한 `서비스 등급`으로 처리된다. 이러한 처리 과정은 라우터에 의해 이루어지므로 기존 응용 프로그램들은 변경할 필요가 없다.

> 00: IP 패킷이 ECN 기능을 사용하지 않음
> 01: ECT 0, TCP 프로토콜도 ECN 기능을 지원
> 10: ECT 1, TCP 프로토콜도 ECN 기능을 지원
> 11: CE, 라우터가 송신 호스트에 혼잡을 통지할 때 사용

**ECN** 필드 값의 의미는 다음과 같다. 송신 호스트가 라우터에게 IP 패킷에 캡슐화된 `TCP 프로토콜이 ECN 기능을 지원한다고 알려주기 위하여 사용`된다. ECN 기능을 위하여 TCP 프로토콜의 헤더에 ECE 필드와 CWR 필드가 추가되었다.

###### (2) 패킷 분할 관련 필드
IP 프로토콜은 상위 계층에서 내려온 전송 데이터가 패킷 하나로 전송하기에 너무 크면 **분할**해 전송하는 기능을 제공한다. 다음은 패킷 분할과 관련된 필드이다.

- **Identification(식별자 혹은 구분자)**: IP 헤더의 두 번째 워드에는 패킷 분할과 관련된 정보가 포함된다. 이 중 Identification 필드는 송신 호스트가 지정하는 `패킷 구분자 기능`을 수행한다. IP 프로토콜이 분할한 패킷들에 동일한 고유 번호를 부여함으로써, 수신 호스트가 Identification 번호가 같은 패킷을 다시 **병합**할 수 있도록 해준다. 패킷을 분할하지 않음녀 패킷을 전송할 때마다 이 필드의 값을 하나씩 증가시킨다.
- **DF**: `패킷이 분할되지 않도록 한다.` 즉 값을 1로 지정하면 패킷 분할을 막을 수 있다. 수신 호스트가 분할되어 입력된 패킷들을 병합하는 기능이 없을 때 사용한다. 따라서 중간 경유 네트워크에서는 자신이 처리 가능한 패킷의 크기보다 큰 IP 패킷에 DF 필드가 설정되어 있으면 분할 기능을 수행하지 않고 패킷을 버린다.
- **MF**: 분할된 패킷을 전송할 때는 여러 개의 분할 패킷이 연속해서 전송되므로 MF 필드 값을 1로 지정하여, `분할 패킷이 뒤에 계속됨을 표시`해주어야 한다. 분할 패킷 중 마지막 패킷은 MF 비트를 0으로 지정하여 분할 패킷이 더 없음을 표시한다.
- **Fragment Offset**: 패킷 분할이 이루어지면 12비트의 Fragment Offset 필드를 사용한다. 저장되는 값은 분할된 `패킷의 내용이 원래의 분할 전 데이터에서 위치하는 상대 주소 값`이다. 값은 8바이트 배수이므로, Fragment Offset 값이 64라면 원래 데이터에서 64 * 8 = 512 번째에 위치한다.

###### (3) 주소 관련 필드
Source Address는 송신 호스트의 IP 주소이고, Destination Address는 수신 호스트의 IP 주소이다. IP 주소 체계는 크게 다섯 종류이다. 클래스 A, B, C는 유니캐스팅에서 이용하고, 클래스 D는 멀티캐스팅에서 이용한다. 클래스 E는 향후의 새로운 응용 환경을 위하여 잠정적으로 예약된 클래스이다.
클래스 A, B, C는 주소를 network와 host 필드로 구분해 관리함으로써, 클래스 별로 네트워크 크기에 따라 주소 관리를 다르게 한다.
- network: 네트워크 주소이다. 전 세계적으로 유일한 번호가 모든 컴퓨터 네트워크에 할당된다. 현재 이 주소의 할당은 NIC에서 담당한다.
- host: 네트워크 주소가 결정되면 하위의 호스트 주소를 의미하는 host 비트 값을 개별 네트워크 관리자가 할당한다. 클래스 A는 host 비트의 크기가 크기 때문에 규모가 큰 네트워크에서 사용하고, 클래스 C는 규모가 작은 네트워크에서 사용한다.

![7-4. IP 주소 체계]()

##### (2) 패킷 분할
하부 계층의 관점에서 보면 TCP에서 설정되는 논리적인 가상 연결은 여러 종류의 네트워크를 거쳐서 설정된다. 그러나 TCP 프로토콜은 패킷 전송 과정에 위치하는 네트워크 유형에 따라 패킷 크기를 조절하기 쉽지 않으므로 IP 프로토콜에서 이 기능을 수행한다.
데이터 링크 계층 프로토콜의 프레임은 크기가 프로토콜마다 다르다. 따라서 상위 게층에서 내려온 데이터를 계층 2의 프레임 틀에 담을 수 있도록 IP 프로토콜에서 분할 과정을 거친 후에 전송하고, 수신 측에서는 이를 다시 합치는 병합 작업을 수행한다.
IP 프로토콜의 분할 기능은 전송 경로에 위치한 라우터에 의해 수행된다. 라우터의 좌우에 연결된 LAN이 서로 다를 수 있기 때문에 데이터 링크 계층에 위치한 프레임 크기가 프로토콜마다 달라진다. 따라서 데이털르 수신한 이후에 패킷을 중개하는 방향에 위치한 LAN에 맞도록 프레임을 분할해주어야 한다.

##### (3) DHCP 프로토콜
특정 네트워크를 관리하는 네트워크 관리자는 개별 호스트들에 수동으로 고정 IP 주소를 할당할 수 있다. 그러나 IP 주소 부족 등의 사유로 ***DHCP**를 사용하여 `IP 주소를 자동으로 할당`할 수 있다. IP 주소를 여러 컴퓨터가 공유해서 사용하면 더 적은 수의 IP 주소만으로도 여러 대의 컴퓨터가 시간 분할 방식으로 인터넷에 접속할 수 있다.
자동으로 할당 가능한 IP 주소는 DHCP 서버가 관리하는 풀에 저장되어 관리되며, 클라이언트로부터 IP 주소 요청이 오면 풀에서 하나의 IP 주소를 할당한다. 이후 사용이 끝나면 다시 IP 주소 풀로 반환되어 다른 호스트가 사용할 수 있다.