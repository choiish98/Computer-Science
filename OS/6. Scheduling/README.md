## 6. Scheduling

### (1) 처리기 스케줄링의 유형
처리기 스케줄링의 목적은 **응답 시간이나 처리량, 효율성을 증대시키기 위해 처리기가 다음에 실행할 프로세스를 선택**하는 것이다.
대부분의 시스템들에서 처리기 스케줄링은 장기, 중기, 단기 스케줄링 3가지로 나뉘어 진다.
이는 프로세스 상태 전이도와 관련하여 프로세스 생성 단계에서는 장기 스케줄링이 적용된다.
그리고 스와핑 과정에서 중기 스케줄링이 적용된다. 마지막으로 단기 스케줄링은 처리기가 다음에 실행할 프로세스를 선택하는 일을 한다.

![스케줄링과 프로세스 상태 전이](https://user-images.githubusercontent.com/56579239/156913889-5dc29ad9-7a26-4b69-96f9-43c9b769dd80.png)

스케줄링의 효율성에 대한 문제는 **프로세스들이 대기 큐에서 대기하는 시간을 얼마나 줄일 수 있는지**가 관건이다.
그리고 근본적으로 **대기 큐의 구조를 최적화**하는 문제도 스케줄링의 성능에 중요한 요소이다.

- **장기 스케줄링**: 장기 스케줄링은 프로세스가 생성 되었을 때, 프로세스를 시스템으로 진입시킬지 말지를 결정한다.
이는 결국 멀티프로그래밍의 정도를 제어하는 역할이다.

  일괄 처리 전용 시스템이나 운영체제의 일괄 처리부에서 새로운 작업들이 들어오면 이들은 일단 디스크 상에 놓아둔 채 일괄 처리 큐 상에서 대기하게 된다.
그러면 장기 스케줄러는 적절한 시점에 이 일괄처리 큐에서 소정의 규정에 따라 작업들을 골라 프로세스로 만들어준다.
따라서 장기 스케줄러는 새로운 프로세스 진입 허용 시점과 어떤 규정으로 작업들을 골라 프로세스로 만들어줄 것이냐를 결정해야 한다.

  새로운 프로세스 진입 허용 시점은 시스템에서 허용 가능한 멀티 프로그래밍의 정도에 따라 달라진다.
진입해있프로세스의 수가 많아지면 그만큼 CPU에 대한 경쟁이 심해지는 것이므로 한 프로세스가 할당받게 될 실행시간은 짧아지게 된다.
따라서 장기 스케줄러는 현재 진입해 있는 프로세스들이 만족할만한 서비스를 제공해줄 수 있는 수준에서 멀티프로그램이의 정도를 제한해야 한다.

- **중기 스케줄링**: 중기 스케줄링은 스와핑 기능의 일부라고 할 수 있다.
어떤 프로세스를 스왑 공간에서 메인 메모리로 불러들이는 일도 결국엔 멀티프로그래밍의 정도를 제어하는 일이라 볼 수 있으므로 스케줄링의 범주에 포함시켜 보면
장기와 단기 스케줄링의 중간 단게에 해당하는 것이다. 스왑아웃된 프로세스 전체 또는 일부 중 어느 것을 다시 스왑인할 것인가를 결정하는 것이 중기 스케줄러가 하는 일이다.

- **단기 스케줄링**: 단기 스케줄러는 디스패쳐라고도 불리는데, 매우 자주 실행되면서 세밀한 기준으로 다음 번에 실행될 프로세스를 선정하는 기능을 한다.
단기 스케줄러가 호출되는 시점은 현재 실행 중인 프로세스가 자발적으로 CPU를 놓거나 또는 자신의 CPU 할당량을 모두 소진한 후 운영체제에게 강제적으로 CPU를 뺏기는 경우에 주로 호출된다.
  
### (2) 스케줄링 알고리즘
- **단기 스케줄링 평가 기준**: 단기 스케줄링의 주된 목적은 시스템의 전체 성능을 높이기 위해 처리기 시간을 프로세스들에게 효율적으로 분배하는 것이다.
스케줄러에 대한 평가는 크게 두 가지 측면으로 나누어 볼 수 있다. 첫 번째 측면은 사용자 중심의 관점에서 평가할 것이냐 아니면 시스템 중심의 관점에서 평가할 것이냐이다.
사용자 중심의 관점이라 함은 개별 사용자 또는 개별 프로세스의 입장에서 자신들에게 긍정적인 영향을 미치는 스케줄러를 평가하는 것을 의미한다.
예를 들면, 어느 시스템의 스케줄러가 최대한 많은 사용자들이 최대 응답 시간 내에 평균 응답 시간을 보장받도록 하는 메커니즘을 제공하는 것이다.  

  시스템 중심의 관점에서는 스케줄러가 처리기를 얼마나 효율적이고도 효과적으로 활용했느냐가 가장 중요한 평가 척도가 된다. 처리량이 가장 대표적인 척도라고 할 수 있다.
처리량은 단위 시간 안에 실행을 완료시킬 수 있는 프로세스의 수를 의미한다. 시스템 성능에 큰 영향을 미치는 척도이기 때문에 스케줄러는 당연히 처리량을 최대로 끌어올릴 수 있도록 노력해야 한다.

  사용자 중심의 관점은 사실 모든 시스템에서 반드시 고려해야할 척도인 반면, 단일 사용자 시스템에서는 시스템 중심의 관점이 그리 중요하지 않을 것이다. 
응답 속도가 적정 수준을 유지해주기만 한다면 처리량이나 처리기 사용률 등의 척도는 그리 중요하지 않을 것이기 때문이다.
또, 성능 중심의 관점에서 평가할 것이냐 아니면 성능과 관련 없는 다른 척도로 평가할 것이냐이다. 성능 중심의 관점에서 사용하는 평가 척도들은 대부분 정량적인 것들이 많고 또 측정하기 용이하다.
하지만 성능과 관련 없는 척도들은 정성적인 특징이 있기 때문에 측정이나 분석이 까다롭다.
예를 들어, 서비스의 성능이 매번 사용할 때마다 같은 성능을 보일 것이라고 기대하는 예측 가능서의 경우 현재 시스템의 부하 정도에 따라 성능이 매번 달라질 수 있다.
하지만 결과 차이를 응답 시간이나 처리량처럼 깔끔하게 측정하기는 쉽지 않다.
  
  이처럼 스케줄러 성능 평가 척도들은 서로 상호 보완적이기 때문에 어떤 스케줄러가 모든 척도를 동시에 최대로 만족시킨다는 것을 불가능하다.
예를 들어, 짧은 응답 시간을 제공하는 스케줄러의 경우 응답 시간을 줄이기 위해서는 프로세스 간 잦은 문맥 교환이 발생하여 오버헤드가 커져서 전체 처리량은 감소할 수 밖에 없다.
따라서 스케줄링 정책을 설계할 때에는 여러 평가 척도들을 섞어서 필요에 따라 조절해야 한다.

- **우선순위 기반 스케줄링**: 많은 시스템들에서 프로세스들에게 우선순위가 부여된다. 그러면 스케줄러는 항상 우선순위가 가장 높은 프로세스를 다음번 프로세스로 선택한다.
우선순위만을 고려하는 순수-우선순위 기반 스케줄링 방식에서의 문제점은 낮은 우선순위의 프로세스가 계속 CPU를 할당받지 못 해 실행되지 못 하여 기아 상태가 발생할 가능성이 있다는 점이다.
기아 상태가 발생하지 않도록 프로세스가 시스템 내에 머무른 시간이나 과거 실행 경력 등을 감안하여 우선순위를 조정해줄 필요가 있다.
다음으로 기아 방지를 포함한 나름대로의 목적을 가진 다양한 스케줄링 정책을 살펴보자.

- **다양한 스케줄링 정책들**: 여러 스케줄링 정책에 대해 표현하는 여러가지 용어의 정의에 대해 먼저 정리한 후, 다양한 스케줄링 정책에 대해 알아보자
  - **선택 함수**: 다음번에 실행을 위해 준비 큐에서 대기 중인 프로세스 중 하나를 고를 때 사용하는 알고리즘을 함수 형태로 표현한 것.
  - **결정 모드**: 선택 함수가 호출되는 시점이 언제인가 하는 것을 나타낸다. 선택 함수가 호출되는 시점에는 두 가지 종류가 있다.
  - **비선점 모드**: 프로세스가 일단 실행 상태에 진입하면 종료되거나 자발적으로 CPU를 놓을 때까지는 CPU를 빼앗기지 않는다.
  - **선점 모드**: 현재 실행 중인 프로세스라 할지라도 운영체제에 의해 인터럽트가 걸려 비자발적으로 준비 큐로 이동될 수 있다.
  
  선점 모등 스케줄링에서는 비선점 모드 스케줄링에 비해 프로세스 간 문맥 교환이 자주 발생하기 때문에 이로 인한 오버헤드가 크다.
하지만 어떤 한 프로세스가 처리기를 오랫동안 독점하는 현상을 방지할 수 있으므로 프로세스 전체에게는 비선점 모드보다 나은 서비스를 제공한다.
요즘의 처리기들은 문맥 교환에 드는 비용을 최소화하기 위해 하드웨어 수준에서 문맥 교환 연산을 제공하기 때문에 오버헤드도 그리 우려할만한 수준은 아닌 것으로 인식되고 있다.
또, 요즘의 시스템들은 메인 메모리 용량이 매우 커서 프로세스 이미지 중 메인 메모리에 올라와 있는 이미지의 비율이 높은 경우가 많아 문맥 교환의 비용 역시 저렴해지는 설정이다.

  - **First-Come-First-Served(FCFS, FIFO)**: FCFS는 가장 단순한 형태의 스케줄링 정책으로써 FIFO라고도 한다. 큐잉 체계를 엄격하게 지키고 있다는 의미이다.
프로세스는 준비 상태가 되면 준비 큐에 들어간다. 현재 실행 중인 프로세스가 실행을 종료하면 준비 큐에서 대기 중이던 프로세스 중 가장 오랫동안 기다렸던 프로세스가 다음번 실행할 프로세스로 선정된다.

    FCFS는 두 가지 문제점을 가지고 있다. 첫 번째로 정규화된 반환 시간이 다른 프로세스들에 비해 엄청나게 크다는 것이다. 실행에 필요한 서비스 시간에 비해 시스템에 머문 시간이 길기 때문이다.
예를 들어, 긴 프로세스 직후에 짧은 프로세스가 도착할 경우 이런 현상이 나타난다. 두 번째로 스케줄링이 점점 진행됨에 따라 입출력 중심의 프로세스보다 처리기 중심 프로세스를 우대하는 경향이 있다는 것이다.
처리기 중심 프로세스가 실행중이라면 입출력 중심 프로세스를 포함한 다른 모든 프로세스들은 일단 기다려야 한다. FCFS는 비선점 모드로 동작하므로 처리기 중심 프로세스가 종료될 때까지 입출력 중심 프로세스는
대기하게 된다. 이는 모든 입출력 장치들을 놀리고 있는 셈이다. 만약 처리기 중심 프로세스가 입출력을 요청하여 입출력 블록 상태로 진입했다고 가정해도, 입출력 중심 프로세스들이 차례로 실행 상태로 진입할 것이고
이들은 대부분 잠깐 실행하면서 또 다른 입출력을 요구한 후 다시 입출력 블록 상태로 진입할 것이다. 이후에 발생하는 최초의 입출력 완료 사건이 있을 때까지 처리기마저도 할 일이 없는 상황이 발생하게 된다.
  
    결론적으로 FCFS는 처리기와 입출력 장치 모두에게 있어서 비효율적인 스케줄링 정책이라 볼 수 있다. 하짐나 FCFS가 우선순위 기반한 스케줄링 정책과 어울러지면 효율적인 스케줄러가 되기도 한다.
우선순위 수준 별로 각각 별도의 큐를 두고 같은 큐에서 대기 중인 프로세스들에 대해서는 FCFS방식으로 스케줄링 하는 것이다.

  - **Round Robin(RR)**: FCFS가에서 짧은 프로세스가 피해보는 현상을 완하하는 가장 간단한 방법은 시간을 측정하고 있다가 어떤 긴 프로세스가 일정 시간 이상을 넘어서는 순간 실행을 강제로
선점시키는 것이다. 프로세스 실행 시간을 재기 위해 필수적인 것이 클록 인터럽트인데, 클록 인터럽트는 일정 간격으로 주기적으로 발생한다.
클록 인터럽트가 발생하면 클록 인터럽트 서비스 루틴이 실행되며 클록 인터럽트 서비스 루틴은 현재 실행 중이던 프로세스는 준비 큐로 이동시키고 준비 큐에서 FCFS 방식으로 다음번 프로세스를 골라
실행시킨다. 이러한 기법을 **시간 할당량(time slicing)** 기법이라고 한다.

    라운드 로빈 스케줄링에서 중요시하는 설계 이슈는 시간 할당량의 길이이다. 시간 할당량이 매우 작다면 짧은 프로세스일수록 상대적으로 일찍 종료될 수 있을 것이지만, 클록 인터럽트가 자주 발생해야
하고, 그에 따라 스케줄링의 횟수와 문맥 교환의 횟수가 증가하므로 시스템 오버헤드가 상당히 커지게 된다.
또, 시간 할당량이 너무 길어 프로세스 중 가장 긴 실행 시간을 갖는 프로세스의 총 실행 시간을 넘어서게 되면 라운드 로빈은 FCFS와 같은 효과를 낸다는 단점이 있다.

    라운드 로빈은 프로세스의 특징은 고려하지 않는 대신 매우 공평하기 때문에 범용 시분할 시스템이나 트랜잭션 처리 시스템에서 효과적인 스케줄링 정책이라 할 수 있다.
하지만 처리기-중심 프로세스와 입출력-중심 프로세스를 차별할 수 밖에 없는 근본적인 한계를 가지고 있다.
보통 입출력-중심 프로세스가 한 번에 사용하는 처리기 시간의 길이는 처리기-중심보다 짧은 것이 일반적이다. 그러다보니 처리기-중심 프로세스와 입출력-중심 프로세스가 섞여 있으면
처리기-중심 프로세스가 처리기를 과다 사용하게 되어 입출력-중심 프로세스의 성능이 떨어지게 된다.

    이러한 단점을 극복하기 위해 가상 라운드 로빈이라고 하는 개선된 라운드 로빈 스케줄링 정책이 있다. 가상 라운드 로빈은 새로 도착한 프로세스는 일단 준비 큐의 끝으로 진입한다.
준비 큐에 있는 프로세스들은 FCFS 방식으로 스케줄링 된다. 실행 중이던 프로세스의 시간 할당량이 만료되면 준비 큐로 들어가 대기한다. 프로세스가 입출력을 요구 했으면 입출력이 완료될 때까지
입출력 큐로 들어가 대기한다. 입출력이 완료된 프로세스는 보조 큐라고 하는 별도의 FCFS 큐로 진입한다. 이후 다음번 프로세스를 고르는 시점에서 스케줄러는 이 보조 큐에 대기 중인 프로세스를
먼저 실행 시킨다. 다만 전번 실행 때 못 채우고 반납한 시간 할당량만큼만 실행하게 하여 처리기-중심 프로세스가 역차별을 당하지 않도록 한다.

  - **Shortest Process Next(SPN)**: FCFS에서 긴 프로세스만 우대하는 편향성을 완화시키는 또 다른 접근법으로 가장 짧은 프로세스를 먼저 실행시키는 정짹인 Shortest Process Next가 있다.
이 정책은 비선점 모드로 동작하는데, 종료 시까지 남아 있는 실행 시간이 가장 짧은 프로세스를 다음 프로세스로 선택한다.
응답 시간을 기준으로 SPN이 FCFS보다 전체 성능이 훨씬 나아지는 경향을 보인다. 하지만 각 프로세스 간의 응답 시간 편차는 긴 프로세스일수록 커지게 되는데 이는 SPN이 예측 가능성 측면에서는
그리 유리하지 못 하다는 것을 의미한다.

    SPN을 구현하는 데에 있어서 어려운 점이 하나 있는데 각 프로세스가 요구하는 총 실행 시간을 미리 알아야 한다는 점이다. 만약 실제 총 시간이 프로그래머가 알려준 총 실행 시간이
프로그래머가 알려준 총 실행 시간 보다 현격히 초과한다면 그 순간 운영체제는 해당 프로세스를 강제로 종료시키면 될 것이다. 또는 각 작업을 몇 번씩 실행시켜 본 후 평균 실행 시간에 대한
통계를 내어 활용해도 좋다.

    SPN 스케줄링 정책에서 발생할 수 있는 단점으로는 짧은 프로세스들이 지속적으로 시스템에 진입한다면 이들보다 상대적으로 긴 프로세스가 기아 상태에 빠질 수 있다는 점이다. 
  이런 현상이 발생하는 이유는 SPN이 비선점 모드로 동작하기 때문이다. 따라서 SPN도 여전히 시분할 시스템이나 트랜잭션 시스템에서는 바람직하지 못한 스케줄링 정책이라 할 수 있다.
  
  - **Shortest Remaining Time(SRT)**: SRT는 SPN 선점 모드 버전에 해당한다. 따라서 SPN에서는 예상되는 전체 실행 시간이 가장 짧은 프로세스가 당음번 프로세스로 선택되었지만 SRT에서는
  예상되는 남아 있는 실행 시간이 가장 짧은 프로세스가 다음번 프로세스로 선택된다. 만약 새로 도착한 프로세스의 예상된느 남아있는 실행 시간이 현재 실행 중인 다른 모든 프로세스들보다
  짧다면 제일 늦게 도착했더라도 현재 실행 중인 프로세스를 선점하고 곧장 선택한다. SRT는 SPN을 좀 더 개선한 버전이라 할 수 있지만 매 스케줄링 때마다 프로세스들의 남아있는 실행 시간을
  평가해야하는 부담은 여전히 존재한다. 또한 SPN에서와 마찬가지로 긴 프로세스가 기아 상태에 빠질 수 있다.
  
    FCFS에서 긴 프로세스를 편애하는 현상은 SRT에선느 발생하지 않으며 라운드 로빈에서는 시간 할당량이 있어 클록 인터럽트가 개입할 수 밖에 없엇지만 SRT에서는 클록 인터럽트가 필요 없다.
  하지만 각 프로세스의 전체 서비스 요구 시간 중 지금까지 얼마나 서비스 받았는지를 기억하고 있어야 하는 오버헤드가 존재한다. 
  반환 시간 측면에서 SRT는 SPN에 비해 월등한 성능을 보이는데 이는 새로 도착한 짧은 프로세스에게 우선권이 주어지기 때문이다.
  
  - **Highest Response Ratio Next(HRN)**: 정규화된 반환 시간은 실제 서비스 시간 대비 반환 시간의 비율을 나타낸다. 개별 프로세스의 입장에서 이 비율이 작을수록 좋은 것은 당연하겠지만,
  전체 프로세스에 대해서도 이 비율의 평균값을 최소화 시키는 방향으로 스케줄러를 최적화 하는 것이 바람직한 방향이라 할 수 있다. 각 프로세스들의 서비스 시간이 얼마나 될 지를 미리 알 수
  없으므로 정확한 구현은 어렵지만 근사치를 구하여 활용할 수는 있다.
  
    현재 실행 중인 프로세스가 종료 했거나 어떤 다른 이유로 실행이 선점되었을 때 스케줄러는 준비 큐에 있는 프로세스 중 응답 비율(처리기 대기 시간 + 예상 서비스 시간 / 예상 서비 시간)이
  가장 큰 프로세스를 다음 프로세스로 선정한다. 이 정책은 프로세스가 시스템 내에 머문 시간을 고려하고 있다는 점에서 상당히 매력적인 편이다.
  물론 서비스 시간이 짧은 프로세스의 응답 비율이 상대적으로 크기 때문에 짧은 프로세스를 우대하는 면이 있지만 대기 시간 때문에 시스템에 오래 머문 긴 프로세스도 오래 머물수록 응답 비율이
  커지기 때문에 홀대 받지 않는다. HRN 정책에서 SPN과 SRT에서와 마찬가지로 예상되는 서비스 시간은 미리 계산되어 있어야 할 것이다.
  
  - **피드백(Feedback)**: 만약 어떤 이유에서건 프로세스들의 예상되는 서비스 시간을 알 수 없다면 SPN, SRT, HRN 스케줄링을 사용할 수 없다. 이러한 상황에서 짧은 프로세스에 대한 선호도를
  높일 수 있는 방법은 오랫동안 실행하고 있는 작업들이 단계적으로 불이익을 받도록 하는 것이다.
  
    스케줄링을 시간 할당량이 있는 선점 모드로 운영하면서 동시에 동적인 우선순위 정책을 병행하여 사용한다. 예를 들어, 어떤 프로세스가 최초로 시스템에 진입하면 처음에는 제일 높은 우선 순위
  큐에 진입하게 된다. 그리고 실행되고 난 후 선점점에 도달하면 다시 준비 상태가 될텐데 이때는 한 단계 낮은 우선 순위 준비 큐로 진입하게 된다. 이런 식으로 선점점을 만날 때마다 프로세스는
  한 단계 낮은 우선순위의 준비 큐로 강등되어 진입한다. 서비스 시간이 짧다면 낮은 우선 순위의 준비 큐로 강등되지 않고도 신속하게 실행을 마칠 것이다. 긴 프로세스일수록 더 낮은 단계의 준비
  큐까지 단계적으로 밀리게 되어 새로 도착한 프로세스일수록, 짧은 프로세스일수록 오래된 프로세스나 긴 프로세스보다 우대받는 정책이 된다.
  각 큐 내에서는 가장 낮은 우선 순위 큐만 제외하면 모두 FCFS 방식으로 다음번 프로세스를 선택한다. 가장 낮은 우선 순위 큐에서는 더 이상 낮은 단계의 큐가 없으므로 라운드 로빈 방식으로
  스케줄링 된다.

  
