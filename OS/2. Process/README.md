## 2. 프로세스

### (1) 프로세스의 정의

- **프로세스**의 정의
  - 수행 중인 프로그램
  - 컴퓨터 상에 수행 중인 프로그램의 인스턴스
  - 처리기에 할당되어 수행될 수 있는 개체
  - 명령들의 순차 수행, 현재 상태, 연계된 시스템 자원들의 집합 등에 의해 특정지어는 활성화 단위

- **프로세스 제어 블록(Process Control Block)**: 프로세스는 프로그램 코드와 데이터의 집합, 프로세스 제어블록 세 가지 요소로 이루어져 있다. 처리기가 프로그램 코드를 수행한다고 가정하면,
그 수행 중인 개체가 프로세스이다. 프로그램이 수행 중 특점 시점에, 프로세스는 다음을 포함한 여러 가지 요소들에 의해 유일하게 식별될 수 있다.
  - **식별자**: 각 프로세스를 다른 모든 프로세스로부터 구별하게 해주는 유일한 식별자
  - **상태**: 프로세스가 현재 수행 중이면, 그 프로세스는 수행 상태에 있다.
  - **우선순위**: 다른 프로세스들에 대해 상대적인 우선순위 수준
  - **프로그램 카운터**: 프로그램에서 다음에 수행될 명령어의 수준
  - **메모리 포인터**: 프로세스와 연계된 프로그램 코드 및 데이터, 다른 프로세스들과 함께 공유되는 메모리 블록에 대한 포인터를 포함한다.
  - **문맥 데이터**: 프로세스가 수행 중일 때, 처리기의 레지스터에 존재하는 데이터
  - **입출력 상태 정보**: 미해결 입출력 요청, 프로세스에 할당된 입출력 장치, 프로세스에 의해 사용 중인 파일들의 리스트를 포함한다.
  - **어카운팅 정보**: 사용된 처리기 시간 및 클록 시간, 시간 제한, 계정 번호 등을 포함할 수 있다.


  ![프로세스 제어블록](https://user-images.githubusercontent.com/56579239/153857692-f9aaebc0-4480-459a-917a-3116229735d4.png)

  
  위의 목록들의 정보는 전형적으로 프로세스 제어블록이라는 자료구조에 저장되며, 프로세스 제어블록은 운영체제에 의해 생성되어 관리된다. 프로세스 제어블록의 주요 역할은 수행 프로세스를 인터럽트 한 후 나중에
  그 인터럽트가 발생되지 않은 것처럼 프로세스 수행을 재개할 수 있도록 충분한 정보를 유지하는 것이다. 프로세스 제어블록은 운영체제로 하여금 다수의 프로세스를 지원하고 멀티프로세싱을 제공할 수 있게
  해 주는 주요 도구이다.

### (2) 프로세스 상태

- 프로세스 궤적: 개별 프로세스 행위의 특성은 그 프로세스를 위해 수행되는 일련의 명령어 리스트로 표현될 수 있다. 이러한 리스트를 프로세스의 **궤적(trace)** 이라 할 수 있다. 
처리기 행위의 특징은 다양한 프로세스들의 궤적이 어떻게 인터리빙 되는지를 보임으로써 표현될 수 있다.


  ![프로세스 궤적 1](https://user-images.githubusercontent.com/56579239/153857733-8841ce6a-7df6-4c4e-aa95-98d4e11f76ec.png)
  ![프로세스 궤적 2](https://user-images.githubusercontent.com/56579239/153857757-6873ec09-c560-47d2-9a62-397f15bf2fe7.png)
  ![프로세스 궤적 3](https://user-images.githubusercontent.com/56579239/153857768-dadb3b90-4352-4e2c-a576-85e92dab1064.png)

  
- **2-상태 프로세스 모델**: 운영체제의 주요 업무는 프로세스의 수행을 제어하는 것이다. 여기에는 프로세스의 수행을 인터리빙 하는 패턴을 결정하는 일과 자원을 프로세스에게 할당하는 일이 포함된다.
프로세스 제어를 위한 운영체제 설계의 첫 단계는 프로세스가 보여 주어야 할 행태를 기술하는 것이다. 어떤 주어진 시점에 하나의 프로세스는 수행 중이거나 그렇지 않다는 건 관찰을 통해 가장
간단하면서도 현실성 있는 모델을 구성할 수 있다. 이 모델에서, 프로세스는 두 가지 상태(**수행**, **비수행**) 중의 한 상태에 있게 된다. 운영체제는 프로세스를 생성할 때, 그 프로세스에 대한
프로세스 제어블록을 생성하고 그 프로세스를 시스템 내에 비수행 상태로 초기화시킨다. 이제 프로세스는 존재 하게 되며 운영체제에 알려져 자신이 수행될 기회를 기다린다.

 ![2-상태 프로세스 모델](https://user-images.githubusercontent.com/56579239/153857789-c9e0f100-5c51-486e-a1ac-59debc8d03db.png)

- 프로세스의 생성과 종료: 현재 관리되고 있는 프로세스 집단에 새로운 프로세스를 추가하고자 할 때, 운영체제는 그 프로세스를 관리하기 위해 필요한 자료구조를 만들고, 그 프로세스에게 주기억장치
내의 주소공간을 할당한다. 일반적으로 네 가지 사건이 발생했을 때 프로세스가 생성된다.
  - 새로운 일괄처리 작업: 보통 테이프나 디스크를 통해 운영체제에게 일괄처리 작업 제어 스트림이 제공된다. 운영체제가 새로운 작업을 처리할 준비가 되면, 다음에 수행할 일련의 작업제어 명령을 읽어 들일 것이다.
  - 대화형 로그온: 사용자가 터미널에서 시스템에 로그온 한다.
  - 서비스를 제공하기 위해 운영체제가 생성: 사용자가 대기할 필요 없도록, 운영체제는 사용자 프로그램을 대신해 어떤 기능을 수행할 프로세스를 생성할 수 있다.
  - 기존 프로세스에 의한 생성: 모듈화를 위해서나 병령성을 활용하기 위해, 사용자 픞로그램은 많은 프로세스의 생성을 명령할 수 있다.
  
  어떤 컴퓨터 시스템이든 프로세스가 수행 완료를 표시할 수 있는 수단을 제공해야 한다. 일괄처리에서 작업의 종료는 중지 명령이나 명시적으로 운영체제 서비스 호출을 수행함으로써 이루어진다.
  중지 명령어는 프로세스가 완료되었다는 사실을 운영체제에게 통보하기 위해 인터럽트를 발생 시킨다. 대화식 응용의 경우, 사용자의 행동에 의해 프로세스의 수행 완료가 표시된다. PC나 워크스테이션
  상에서 사용자는 응용을 중단시킬 수 있다. 이러한 모든 행동은 궁극적으로 해당 프로세스를 종료시키기 위해 운영체제에게 서비스를 요청하게 된다. 또한 여러 종류의 오류 및 결함 상태로 인해 프로세스가 종료될 수 있다. 마지막으로 운영체제에서는 프로세스가 그 자신을 생성한 프로세스에 의해서 종료되거나 부모 프로세스가 종료될 때 같이 종료되기도 한다.
  
- **5-상태 프로세스 모델**: 모든 프로세스들이 항상 수행할 준비가 되어 있다면, 2-상태 모델이 효과적일 것이다. 하지만 2-상태 모델에서는 비수행 상태의 프로세스를 수행할 프로세스로 선정하는 데에
  큐를 이용한 선입선출을 리스트를 사용하고, 처리기는 수행 가능한 프로세스를 라운드-로빈 형식으로 처리한다. 이러한 경우 2-상태 모델의 구현 방법을 적절하지 않다. 비수행 상태에 있는 어떤
  프로세스들은 수행할 준비가 되어 있지만, 다른 프로세스들은 입출력 연산이 완료되기를 기다리면서 블록되어 있을 수 있다. 따라서 단일 큐를 사용할 때 디스패처는 단순히 큐의 맨 끝에서부터
  프로세스를 선택하지 않아야 한다.
  
  이러한 상황을 보다 자연스럽게 처리하기 위해서는 비수행 상태를 준비 상태와 블록 상태로 분할하는 것이 좋다. 적절한 대책으로 또 다른 두 가지 상태를 추가하였다. 새로운 다이어그램에 나타난
  다섯 가지 상태는 다음과 같다.
  
  ![5-상태 프로세스 모델](https://user-images.githubusercontent.com/56579239/153857809-bb6fc635-0727-462c-92c4-a313801d0c76.png)
  
  - **수행(Running)**: 현재 수행 중인 프로세스
  - **준비(Ready)**: 기회가 주어지면 수행될 준비가 되어 있는 프로세스
  - **블록/대기(Blocked/Waiting)**: 입출력 연산 완료 등과 같은 어떤 이벤트가 발생할 때까지 수행될 수 없는 프로세스
  - **생성(New, 시작)**: 지금 막 생성되었지만 운영체제에 의해 수행 가능한 프로세스 풀로 진입이 아직 허용되지 않은 프로세스
  - **종료(Exit)**:  프로세스 수행이 중지되거나 어떤 이유로 중단되었기 때문에 운영체제에 의해 수행가능 프로세스 풀에서 방출된 프로세스
  
  프로세스의 상태 전이를 일으키는 이벤트들의 종류가 나타나 있다. 가능한 전이는 다음과 같다.
  - **널(Null) -> 생성**: 어떤 프로그램을 수행하기 위해 새로운 프로세스가 생성된다.
  - **생성 -> 준비**: 운영체제가 새로 생성된 프로세스를 받아들일 준비가 되었을 때, 그 프로세스를 생성 상태에서 준비 상태로 전이시킨다.
  - **준비 -> 수행**: 수행할 프로세스를 선택할 때가 되면, 운영체제는 준비 상태에 있는 프로세스들 중 하날르 선택한다.
  - **수행 -> 종료**: 현재 수행 중인 프로세스가 작업을 완료하거나 수행이 중단되면 운영체제는 그 프로세스를 종료시킨다.
  - **수행 -> 준비**: 이 전이가 발생하는 가장 일반적인 경우는 수행되고 있던 프로세스가 처리기 시간을 모두 사용했을 경우이다. 이외에 *선점*의 경우에도 이 전이가 발생한다.
  - **수행 -> 블록**: 프로세스가 자원을 요구했는데 기다려야 한다면 블록 상태로 전이된다.
  - **블록 -> 준비**: 블록 상태에 있는 프로세스는 자신이 기다리고 있던 이벤트가 발생하게 되면 준비상태로 전이된다.
  
- **보류된 프로세스(Suspended Process)**: - 메인 메모리에는 여러 프로세스들이 존재하고, 처리기는 한 프로세스가 대기 상태가 되면 다른 프로세스로 이동할 수 있다. 하지만 처리기가 입출력 장치보다는 훨씬 빠르기 때문에 일반적으로 메모리에 있는 모든 프로세스들은 입출력이 완료되기를 기다릴 것이다.

  이에 대한 해결책으로 **스와핑(swapping)**이 있다. 이는 프로세스의 일부나 전체를 주기억장치로부터 디스크로 옮겨 놓는 방법이다. 주기억장치에 있는 프로세스들 중에서 준비 상태에 있는 프로세스가 하나도 없다면 운영체제는 블록된 프로세스들 중에서 하나를 디스크로 내보내고 보류큐에 넣는다. 그 다음, 운영체제는 보류큐에 있는 다른 프로세스를 주기억장치로 들여오거나 새로운 프로세스 요청을 받아들인 후 새로 도착한 프로세스를 수행한다.

  스와핑을 사용하려면 또 다른 상태, 즉 **보류상태**가 프로세스 행위 모델에 추가되어야 한다. 주기억장치에 있는 모든 프로세스들이 블록 상태라면 운영체제는 한 프로세스를 보류 상태로 만들고 디스크로 전송한다. 이 때, 주기억장치에 생긴 여유 공간은 다른 프로세스를 불러들이는데 사용될 수 있다.

  하지만 보류되어 있는 모든 프로세스는 보류될 때 블록 상태에 있었던 것들이다. 따라서 프로세스가 여전히 수행될 준비가 되어있지 않았다면 이는 효과가 없을 것이다. 그러나 보류 상태에 있는 각 프로세스들은 원래 특정 이벤트를 기다리며 블록되어 있었기 때문에 해당 이벤트가 발생하였담녀 그 프로세스는 블록되지 않고 수행될 가능성이 있다. 그러므로 운영체제는 설계에서 다음과 같은 측면을 다시 생각해 보아야 한다. 이러한 조건들을 수용하기 위해 다음과 같은 네 가지 상태가 필요하다.

  - **준비(Ready)**: 프로세스가 주기억장치에 있고 수행될 수 있다.
  - **블록(Blocked)**: 프로세스가 주기억장치에 있고 사건을 기다리고 있다.
  - **블록/보류(Blocked/Suspend)**: 프로세스가 보조기억장치에 있고 사건을 기다리고 있다.
  - **준비/보류(Ready/Suspend)**: 프로세스가 보조기억장치에 있고 적재 시 즉시 수행될 수 있다.

  ![7-상태 프로세스 모델](https://user-images.githubusercontent.com/56579239/154273141-5f515d06-c2a9-4a1e-94a8-3cc2edb8ab98.png)

  *7-상태 프로세스 모델*

  - **블록 -> 블록/보류**: 준비된 프로세스가 하나도 없다면 적어도 하나의 블록된 프로세스를 스왑아웃 시켜 다른 프로세스를 불러들일 공간을 마련해야 한다. 현재 수행 중인 프로세스나 디스패치될 준비 된 프로세스가 더 많은 주기억장치를 요구할 경우 블록된 프로세스는 보류된다.
  - **블록/보류 -> 준비/보류**: 기다리고 있던 이벤트가 발생하면 준비/보류 상태로 전이한다.
  - **준비/보류 -> 준비**: 준비된 프로세스들이 주기억장치에 없으면 운영체제는 수행을 계속하기 위해 프로세스를 반입한다. 준비/보류 상태에 있는 프로세스가 준비 상태에 있는 프로세스보다 더 높은 우선순위를 가질 경우 스와핑을 최소화하기 보다 높은 우선순위를 가진 프로세스를 가져오는 것이 더 중요할 수 있다.
  - **생성 -> 준비/보류 및 생성 -> 준비**: 새로운 프로세스에게 할당할 공간이 충분하지 않을 경우, 새로운 프로세스가 생성될 때, 준비 큐나 준비/보류 큐에 추가될 수 있다.
  - **블록/보류 -> 블록**: 가장 높은 우선순위를 가진 프로세스가 블록/보류 큐에 있고 운영체제는 그 프로세스가 기다리고 있는 이벤트가 곧 발생할 것이라고 판단했다고 가정하자. 이런 상황에서 준비/보류 상태의 프로세스보다 우선해서 블록/보류된 프로세스를 주기억장치로 가져온다.
  - **수행 -> 준비/보류**: 수행 중인 프로세스가 자신에게 할당된 처리기 시간을 다 사용하였을 때, 블록/보류 큐에 우선순위가 더 높은 프로세스가 있다면 프로세스를 준비/보류 큐로 옮겨 주기억장치 공간을 사용가능하게 만들 수 있다.
  - **임의 상태 -> 종료**: 부모 프로세스가 자식 프로세스를 종료시킬 때, 어떤 상태에 있건 종료 상태로 전이될 수 있다.

  보류된 프로세스의 개념을 일반화할 수 있는데 보류 상태의 프로세스는 다음과 같은 특성을 가지고 있다.

  - 즉시 수행될 수 없다.
  - 사건을 기다리고 있을 수도 있고 그렇지 않을 수도 있다. 사건을 기다리고 있을 경우 해당 블록 상태의 조건은 보류 상태의 조건과는 독립적이므로 그 블록 상태를 해제시킬 사건이 발생하더라도 수행될 수 없다.
  - 어떤 프로세스 자체나 부모 프로세스 혹은 운영체제가 프로세스의 수행을 막기 위해 그 상태를 보류 상태로 바꾸었다.
  - 에이전트가 명시적으로 해제 명령을 내릴 때까지 보류 상태에서 벗어날 수 없다.

### (3) 프로세스 기술(description)

- 운영체제 제어 구조: 운영체제는 프로세스 관리를 위해 **프로세스 테이블**을 유지한다. 메모리와 입출력 장치, 파일들은 모두 프로세스를 위해 관리되기 때문에 프로세스 테이블에서 이들 자원에 대한 참조가 직접 또는 간접적으로 이루어져야 한다. 파일 테이블을 통해 참조되는 파일들은 입출력 장치를 경유하여 접근될 수 있고 어떤 경우에는 주기억장치나 가상메모리 내에 존재할 것이다. 이러한 테이블들은 운영체제에 의해 접근될 수 있어야 하므로 메모리 관리에 종속적이다.

- 프로세스 제어 구조: 운영체제는 프로세스를 관리하고 제어하기 위해 프로세스의 위치와 프로세스의 속성을 고려해야 한다. 프로세스에서 사용되는 속성들의 집합을 **프로세스 제어블록**이라 부르며, 프로그램과 데이터, 스택, 속성들의 집합을 **프로세스 이미지**라 부른다.

  프로세스의 위치는 각 프로세스에 대한 하나의 항목을 가진 주 프로세스 테이블에 저장된다. 각 항목은 최소한 프로세스 이미지에 대한 포인터를 포함하며, 프로세스 이미지가 여러 블록으로 구성되어 있다면 이 내용은 주 프로세스 테이블에 직접 저장 관리되거나 메모리 테이블에 있는 상호 참조가 가능한 항목에 의해 이용 가능하다.

  프로세스 속성은 프로세스 제어블록에 저장될 수 있다. 프로세스 제어블록에 있는 정보들은 크게 세 가지 범주로 나눌 수 있다.

  - **프로세스 식별**: 모든 운영체제는 각 프로세스에 유일한 식별자를 할당한다. 이 식별자는 단순히 주 프로세스 테이블에 대한 인덱스이다. 그리고 작업에 대해 책임지고 있는 사용자를 지시하기 위해 사용자 식별자가 각 프로세스에 할당될 수 있다.
  - **처리기 상태 정보**: 처리기 레지스터의 내용들로 구성된다. 프로세스가 수행되는 동안에는 정보가 레지스터에 있다.  프로세스가 인터럽트 되어 중단되면 모든 레지스터 정보들은 저장되어야 하는데, 이유는 프로세스의 수행이 재개될 때 다시 정보를 복구하기 위해서이다.
  - **프로세스 제어 정보**: 프로세스 제어 정보는 운영체제가 활성화 된 여러 프로세스들을 제어하고 조정하기 위해 필요한 추가 정보이다. 운영체제가 스케줄링 기능을 수행하기 위해 프로세스 상태, 우선순위, 스케줄링 관련 정보, 이벤트를 저장한다. 그리고 프로세스의 자료구조화, 통신, 권한, 메모리 관리, 자원의 소유권과 이용률에 대해 저장한다.

  프로세스 제어블록은 운영체제에서 가장 중요한 자료구조이다. 각 프로세스 제어블록에는 운영체제에 필요한 프로세스의 모든 정보들이 들어 있다. 이 블록들은 스케줄링, 자원 할당, 인터럽트 처리, 성능 측정과 분석 등에 대한 관련된 모듈들을 포함하여 운영체제의 모든 모듈에 의해 읽혀지고 수정될 수 있다. 따라서 프로세스 제어블록의 집합은 운영체제의 상태를 정의한다고 할 수 있다.

- 프로세스 제어: 프로세스 제어블록은 운영체제에서 중요한 역할을 맡고 있고, 모든 모듈은 프로세스 제어블록에 접근한다. 이는 설계에 있어서 중요한 문제를 야기한다. 운영체제 내에 있는 수많은 루틴들은 프로세스 제어블록에 있는 정보들에 접근할 필요가 있다. 문제는 수많은 루틴이 접근하는 제어블록의 보안에 있다. 이에 대한 문제는 다음과 같다.

  - 인터럽트 핸들러와 같은 단일 루틴에서의 버그가 프로세스 제어블록에 손상을 줄 수 있고, 결국 해당 프로세스를 관리하는 시스템 기능이 파괴될 수 있다.
  - 프로세스 제어블록의 구조와 의미 부분의 설계가 변경되면 수많은 운영체제 모듈이 영향을 받게 될 것이다.

  운영체제는 이와 같은 문제를 해결하기 위해 **사용자 모드, 시스템 모드, 제어 모드, 커널 모드**와 같은 프로세스에 대한 제어를 하기 시작했다.
  
  
