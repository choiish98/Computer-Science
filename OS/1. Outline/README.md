## 1. 개요

### (1) 컴퓨터 시스템 개요

- 목적: 운영체제는 하나 이상의 처리기로 구성된 하드웨어 자원을 활용하여 시스템 사용자에게 다양한 서비스를 제공한다. 또한 운영체제는 사용자 관점에서 보조기억장치와 입출력 장치를 관리한다. 따라서 운영체제를 살펴보기 전에 그 기반이 되는 컴퓨터 시스템 하드웨어를 어느 정도 이해하는 것이 중요하다.

- 기본 구성 요소
  - **처리기(프로세서, processor)**: 컴퓨터의 동작을 제어하고 데이털르 처리한다. 처리기가 하나만 있는 경우에는 일반적으로 중앙처리장치(CPU)라고 한다.
  - **주기억장치(main  memory)**: 데이터와 프로그램을 저장한다. 전형적으로 휘발성이기 때문에, 컴퓨터가 셧다운 될 경우 메모리의 내용이 없어지게 된다. 대조적으로, 디스크 메모리의 내용은 컴퓨터가 셧다운되더라도 유지된다. 주기억장치는 실기억장치 혹은 주메모리라고도 불린다.
  - **입출력 모듈(I/O module)**: 컴퓨터와 외부 환경 간의 데이터 이동을 담당한다. 외부 환경은 보조기억장치, 통신장비, 그리고 단말기를 포함한 다양한 외부 장치로 구성된다.
  - **시스템 버스(System bus)**: 처리기, 주기억장치, 그리고 입출력 모듈간의 통신을 제공한다.

- 명령어 수행: 단일 명령어 수행에 필요한 처리 과정을 명령어 사이클이라고 한다. 단순화된 2-단계 설명ㅇ을 사용하여 명령어 사이클을 나타내면 반입단계와 수행 단계로 나타낸다.

  ![제목 없음](C:\Users\SH.C\Desktop\운영체제\프로그램 수행의 예.png)

  *메모리와 레지스터의 프로그램 명령어 수행의 예*

- 인터럽트: 가상적으로 모든 컴퓨터는 처리기의 일반적인 처리에 다른 모듈들이 인터럽트를 걸 수 있도록 허용하고 있다. 인터럽트는 기본적으로 처리기의 처리율을 향상시키기 위해 제공된다. 예를 들어 대부분의 입출력 장치들은 처리기에 비해 훨씬 느리다. 명령어 사이클 기법을 사용하여 처리기가 프린터로 데이터를 전송한다고 가정하자. 매번 쓰기 연산 이후, 처리기는 수행을 일시 중단하고 프린터가 출력을 완료할 때까지 유휴상태가 된다. 이러한 중단 시간은 수백 또는 수천 개의 처리기 명령어 사이클을 낭비하게 된다.

  ![인터럽트 예시](C:\Users\SH.C\Desktop\운영체제\인터럽트 예시.png)

  *인터럽트 예시*

- 메모리 계층 구조: 메모리 관련 세 가지 주요 특성인 **용량**, **접근속도** 그리고 **비용** 간에는 상호 절충 관계가 있다.

  - 접근 시간이 짧을 수록 비트당 비용이 높아짐
  - 용량이 클수록 비트당 비용이 낮아짐
  - 용량이 클수록 접근 시간이 길어짐

  이러한 딜레마를 벗어나기 위해 단일 메모리 요소나 기술에 의존하지 않고 메모리 계층 구조를 채택하여 사용한다. 크고 저렴하고 속도가 느린 메모리가 작고 비싸고 빠른 메모리를 보완한다. 이런 구성의 성공 열쇠는 저속의 메모리에 대한 접근 회수를 줄이는 것이다. (캐시, 참조지역성)

  ![메모리 계층 구조 예](C:\Users\SH.C\Desktop\운영체제\메모리 계층 구조 예.png)

  *메모리 계층 구조*

- 캐시 메모리: 처리기의 명령어 수행 속도는 명령어 사이클 시간에 의해 제약을 받는다. 이러한 제약은 처리기와 주기억장치 속도 차이로 인해 심각한 문제가 된다. 이상적으로는 메모리 사이클 시간과 처리기 사이클 시간이 비슷하도록 주기억장치도 처리기 레지스터가 채택한 것과 동일한 기술을 이용하여 구축되어야 한다. 그러나 이런한 전략을 채택하는 것은 항상 너무 많은 비용이 든다. 해결책은 처리기와 메모리 간에 캐시와 같은 용량은 적으나 빠른 메모리를 제공함으로써 지역성의 원리를 이용하는 것이다.

  비교적 대용량이고 속도가 느린 주기억장치가 소용량이지만 속도가 빠른 캐시와 함께 사용된다. 캐시는 주기억장치 일부의 복사본을 포함하고있다. 처리기가 메모리에서 한 워드를 읽으려 할 때, 그 워드가 캐시 내에 있는지 여부를 점검해야 한다. 만약 그렇다면 그 워드는 처리기로 전달된다. 그 워드가 캐시 내에 존재하지 않으면, 약간의 고정된 개수의 워드로 구성된 주기억장치 블록이 캐시로 읽혀진 뒤, 해당 워드가 처리기로 전달된다. **참조 지역성** 때문에, 어떤 메모리의 참조를 위해 ㅏ나의 데이터 블록을 캐시로 가져오게 되면, 그 이후의 참조는 그 블록내에 있는 한 워드가 될 확률이 높다.

  ![캐시 메모리 예](C:\Users\SH.C\Desktop\운영체제\캐시 메모리 예.png)

  *캐시 메모리 예*

- 직접 메모리 접근(DMA): 대량의 데이터가 이동되어야 할 때, 직접 메모리 접근과 같은 효율적인 기술이 요구된다. DMA 모듈은 프로세서를 거치지 않고 데이터 블록 전체를 한 번에 한 워드씩 메모리로부터 또는 메모리로 전송한다. 전반적으로 볼 때 DMA 전송 동안 프로세서의 수행이 조금 느려지게 된다. 그럼에도 불구하고 다수의 워드에 대한 I/O 전송의 경우 DMA가 인터럽트 구동이나 프로그램된 입출력에 비해 훨씬 효과적이다.

- 멀티 프로세서와 멀티 코어

  - **SMP**: SMP는 컴퓨터 하드웨어 구조나 그 구조를 활용하는 운영체제의 행동 양식을 일컫는다. SMP는 달이처리기 구조에 비해 아래와 같은 일련의 잠재적 장점들을 가진다.

    - 성능: 컴퓨터가 수행해야 할 작업의 일부가 병렬로 처리될 수 있다면, 여러 개의 처리기로 구성된 시스템은 동일한 타입의 단일 처리기로 구성된 시스템에 비해 많은 성능 향상이 가능하다.
    - 가용성: 대칭형 멀티 프로세서 시스템에서 모든 처리기들이 동일한 기능을 수행할 수 있기 때문에, 하나의 처리기가 고장나더라도 시스템은 다소 성능이 떨어진 상태에서 지속적으로 동작할 수 있다.
    - 점진적 확장: 사용자는 성능 향상을 위해 필요할 때마다 처리기를 추가로 설치할 수 있다.
    - 크기 조저이 벤더들은 시스템을 구성하는 처리기의 수에 따라 가격과 성능이 다른 다양한 제품을 공급할 수 있다.

    ![대칭형 멀티 프로세서](C:\Users\SH.C\Desktop\운영체제\대칭형 멀티 프로세서.png)

    *대칭형 멀티 프로세서 구조*

  - **멀티코어 컴퓨터**: 하드웨어의 발전, 클럭 주파수의 증가와 멀티 컴퓨터의 구성 요소를 점차 소형할 수 있는 능력이 프로세서에 캐시를 보다 가깝게 놓을 수 있도록 만들었다. 명령어 실행과 메모리 접근의 병렬화를 이용함에 따라 성능도 프로세서 디자인의 복잡도가 증가함에 따라 증가되었다. 설계자들은 하드웨어 고급화의 이점으로 성능을 증가시킬 수 있는 최고의 방법으로 다중 프로세서와 상당한 양의 캐시 메모리를 단일 칩에 넣는 것임을 발견했다.

    ![멀티 코어 블럭 다이아그램](C:\Users\SH.C\Desktop\운영체제\멀티 코어 블럭 다이아그램.png)

    *멀티 코어 블럭 다이어그램*

    

### (2) 운영체제 개요

- 목적 및 기능: 운영체제는 응용 프로그램의 수행을 제어하고 응용 프로그램과 컴퓨터 하드웨어 사이의 인터페이스 역할을 하는 프로그램이다. 운영체제의 목적으로는 다음과 같은 세 가지를 들 수 있다.

  - 편리성: 운영체제는 컴퓨터를 보다 편리하게 사용할 수 있게  해준다.
  - 효율성: 운영체제는 컴퓨터 시스템 자원을 효율적으로 사용할 수 있게 해준다.
  - 발전성: 운영체제는 효과적인 개발과 시험이 가능해야하고, 서비스를 방해하지 않고 새로운 시스템 기능을 도입할 수 있도록 구축되어야 한다.

  

  - 사용자/컴퓨터 인터페이스로의 운영체제: 사용자에게 응용 프로그램을 제공하기 위해 사용되는 하드웨어와 소프트웨어는 다음과 같은 계층적인 방식으로 살펴볼 수 있다.

    ![운영체제 계층 구조](C:\Users\SH.C\Desktop\운영체제\운영체제 계층 구조.png)

    *운영체제의 계층 구조*

    

    컴퓨터 하드웨어의 제어를 완전히 담당하는 기계 명령어의 집합으로 응용 프로그램을 개발해야 한다면, 프로그래머는 굉장히 복잡한 작업을 처리해야 한다. 복잡한 개발 과정의 처리를 쉽게 하기 위해 유틸리티 또는 라이브러리와 같은 다양한 시스템 프로그램들이 제공된다. 프로그래머는 응용을 개발하기 위해 이러한 기능을 이용하고, 응용 프로그램은 수행되는 동안 원하는 기능을 수행하기 위해 유틸리티를 활용한다. 가장 중요한 시스템 프로그램들을 모아 놓은 것을 운영체제라고 할 수 있다.

    운영체제는 일반적으로 다음과 같은 서비스를 제공한다.

    - **프로그램 개발**: 운영체제는 프로그래머가 프로그램을 작성하는 것을 지원하기 위해 문서 편집기, 디버거 등의 기능과 서비스를 제공한다.
    - **프로그램 실행**: 하나의 프로그램이 실행되기 위해서는 운영체제에 의해 여러 단계를 거친다. 명령어와 데이터가 주기억장치에 적재되어야 하고, 입출력 장치와 파일들이 초기화되어야 하며, 필요시 다른 자원들도 준비되어야 한다. 운영체제는 사용자를 대신하여 필요자원을 스케줄링 하는 의무를 수행한다.
    - **입출력 장치 접근**: 각 입출력 장치는 동작을 위해 자기 자신만의 독특한 명령어나 제어 시그널을 필요로 한다. 운영체제는 이 같은 세부사항을 감추어 프로그래머가 단순히 읽기와 쓰기 관점에서 입출력장치를 사용할 수 있도록 일관된 인터페이스를 제공한다.
    - **파일 접근 제어**: 파일의 제어를 위해서 운영체제는 입출력장치의 특징뿐만 아니라 저장 매체 상에서의 파일 형식에 대한 정보도 반영한다. 또한 여러 명의 동시 사용자를 지원하는 시스템의 경우에 운영체제는 파일에 대한 접근을 제어하기 위해 보호 기법을 제공하기도 한다.
    - **시스템 접근**: 운영체제는 시스템 전체 및 특정 시스템 자원에 대한 접근을 제어한다. 접근 제어 기능은 불법 사용자로부터 자원과 데이터를 보호해야 하며, 자원을 동시에 접근할 때 발생할 수 있는 자원경쟁 문제를 해결해야 한다.
    - **에러 발견 및 응답**: 운영체제는 수행 중인 응용 프로그램에 대한 에러의 영향을 최소화 하면서 에러 조건을 제거할 수 있도록 응답해야 한다.
    - **어카운팅(accounting)**: 여러 가지 자원에 대한 사용 통계를 수집하고 응답시간 같은 성능 척도를 모니터링한다. 어떤 시스템에서든지 이러한 정보는 향후 기능 보완의 필요성을 미리 예상하거나 성능 향상을 위해 시스템을 튜이하는데 유용하다.
    - **인스트럭션 셋 구조(ISA)**: ISA는 컴퓨터가 따르고 있는 기계 명령어의 집합 규정을 정의한다. 이 정의에 의해 만들어진 인터페잇느느 하드웨어와 소프트웨어의 경계에 해당한다. 응용 프로그램과 유틸리티의 바이너리들은 모두 ISA에 의해 정의된 명령어를 직접 사용해 동작한다.
    - **응용 실행파일 인터페이스(ABI)**: ABI는 이 기종 기계 상의 프로그램 간 또는 서로 다른 컴파일러가 생산하는 실행파일 간 바이너리 호환성을 지원하기 위한 표준이다. 사용자 ISA에 의해 접근이 가능한 하드웨어 자원이나 서비스, 또는 운영체제로 전달되는 시스템 콜 인터페이스를 규정하고 있다.
    - **응용 프로그래밍 인터페이스(API)**: API는 프로그램들이 사용자 ISA를 통해 시스템에 있는 하드웨어 자원과 서비스에 접근할 수 있도록 해주는 수단으로 대부분 고수준 프로그래밍 언어의 라이브러리 함수 형태를 갖는다. 운영체제에서 제공하는 시스템 콜도 실제로는 라이브러리 함수 API가 호출한다.

    

  - 자원 관리자로서의 운영체제: 컴퓨터는 데이터의 이동, 저장, 처리와 이들 기능을 제어하는데 필요한 자원들의 집합이다. 운영체제는 이들 자원의 관리를 책임진다. 컴퓨터의 자언을 관리함으로써 운영체제는 컴퓨터의 기본 기능을 제어한다. 운영체제는 보통의 경우와는 다른 다음과 같은 관점에서 제어를 한다.

    - 운영체제는 일반적인 소프트웨어와 똑같이 동작한다. 즉 운영체제도 처리기에 의해 수행되는 하나의 또는 일련의 프로그램이다.
    - 운영체제는 빈번히 처리기를 응용 프로그램에게 양도하는데, 제어를 돌려받는 것도 처리기에 의존해야 한다.

    다른 컴퓨터 프로그램과 마찬가지로 운영체제도 처리기에게 명령어(코드)를 제공한다. 주요한 차이는 그 프로그램의 의도이다. 운영체제는 처리기에게 다른 시스템 자원의 사용을 지시하며 다른 프로그램이 수행될 시점을 결정한다. 그러나 이런 작업을 하려면 처리기는 운영체제 프로그램의 수행을 중지시키고 다른 응용 프로그램을 수행해야 한다. 이때, 운영체제는 처리기가 어떤 유용한 작업을 할 수 있도록 제어를 양도한 뒤, 처리기가 다음 응용의 수행을 준비하는 데 충분한 시간 동안 제어를 돌려받는다.

    주기억장치에는 운영체제에서 가장 빈번히 사용되는 기능들을 포함하고 있는 커널과 당시 사용중인 OS 부분들이 적재된다. 운영체제는 수행 중인 프로그램이 언제 입출력 장치를 상용할 수 있는 질르 결정하며 파일에 대한 접근과 사용을 제어한다. 처리기 자체도 자원이기 때문에 운영체제는 특정 사용자 프로그램의 수행을 위해 처리기 시간을 얼마나 할당할 지 결정해야 한다. 멀티 프로세서의 경우, 이러한 결정은 모든 처리기에 대해 이루어져야 한다.

    

  - 운영체제 발전의 용이성: 운영체제는 다음과 같은 여러가지 이유로 인해 계속적으로 발전할 것이다.
    - 하드웨어 업그레이드와 새로운 형태의 하드웨어
    - 새로운 서비스
    - 버그 수정

  

- 운영체제의 발전: 운영체제가 제공해야 할 핵심 사항과 최신 운영체제의 주요 기능들이 갖는 의미가 무엇인지를 알기 위해서는 지난 수십 년 동안 운영체제가 어떻게 발전해 왔는지를 살펴볼 필요가 있다.

  - **순차 처리(Serial Processing)**: 초창기 컴퓨터에는 운영체제가 지원되지 않았기 때문에 프로그래머가 컴퓨터 하드웨어를 직접 다루어야 했다. 이와 같은 초기 시스템에는 두 가지 큰 문제점이 존재하고 있었다.

    - **스케줄링(scheduling)**: 기계에 소프트웨어를 설치하려면 기계 사용시간을 예약하기 위해 등록용지를 이용하였다. 사용자는 통상 30분 단위로 예약할 수 있었다. 사용자가 1시간을 예약하고 실제로는 45분만 사용했다면 15분에 다른 사용자가 들어올 수 없으므로 컴퓨터 처리 시간이 낭비되는 결과를 초래한다.
    - **준비시간(setup time)**: 단일 프로그램이 수행되기 위해서는 컴파일러와 고급언어 프로그램(소스 코드)을 주기억장치에 적재하고, 컴파일된 프로그램(바이너리 실행파일)을 저장장치에 저장한 다음, 바이너리 실행파일과 공용 함수들을 함께 적재하여 링크해야 한다. 이 과정에서 에러가 발생하면 사용자는 절차를 처음부터 다시 반복해야 한다.

    이와 같이 사용자가 컴퓨털르 순차적으로 접근하기 때문에, 이러한 형태의 처리를 순차처리라 한다. 시간이 흐름에 따라 효율적인 순차처리를 위해 다양한 시스템 소프트웨어 도구들이 개발되었다. 여기에는 여라 사람이 공동으로 이용할 수 있는 라이브러리 함수, 링커, 로더, 디버거, 입출력 드라이버 루틴 같은 소프트웨어가 포함된다.

  - **단순 일괄처리 시스템(Simple Batch System)**: 초창기의 컴퓨터는 컴퓨터의 이용률을 극대화하는 것이 중요하였다. 따라서 스케줄링과 준비시간 때문에 시간이 낭비되는 것은 용납될 수 없었다. 일괄처리 운영체제 개념은 컴퓨터의 이용률을 향상시키기 위해 개발되었다.

    단순 일괄처리 기법의 기반이 되는 아이디어는 **모니터**라고 알려진 소프트웨어를 사용하는 것이다. 이러한 운영체제가 이용 가능해짐에 따라 사용자는 더 이상 작업을 처리 단계별로 컴퓨터에게 직접 명령을 내릴 필요가 없게 되었다. 그 대신 사용자는 작업을 카드나 테이프에 담아 컴퓨터 오퍼레이터에게 제출하고, 오퍼레이터는 작업들을 순서대로 한데 모아 모니터가 처리할 수 있도록 전체 작업묶음(batch)을 입력 장치에 넣는다. 각 프로그램의 실행이 완료되면 제어가 모니터로 넘어가게 함으로써 모니터가 그 시점에서 자동으로 다음 프로그램을 적재할 수 있데게 하였다. 이와 같이 모니터는 스케줄링 문제를 해결할 수 있다.

    일괄처리 운영체제에서는 사용자 프로그램과 모니터가 번갈아 수행된다. 이로 인하여 주기억장치의 일부를 모니터가 계속 차지해야 하고, 약간의 컴퓨터 시간을 모니터가 사용하는 등의 두 가지 오버헤드가 발생한다. 이러한 오버헤드에도 불구하고 단순 일괄처리 시스템만으로도 컴퓨터 이용률을 향상시킬 수 있다.

  - **멀티프로그래밍 일괄처리 시스템(Multiprogrammed Batch System)**: 단순 일괄처리 운영체제를 통해 작업 처리 순서가 자동으로 결정되는 경우에도 처리기는 처리 할 일이 없어 자주 유휴상태에 있을 수 있다. 문제는 입출력 장치의 속도가 처리기에 비해 느리다는 것이다. 처리기는 입출력 명령어가 수행되기 전까지 계산을 위해 CPU  시간을 얼마간 사용한 다음 입출력 명령어가 완료되기까지 대기해야 한다. 이러한 비효율성은 당연히 불필요한 것이다. 

    주기억장치의 크기가 모니터와 여러 개의 사용자 프로그램이 적재될 수 있도록 충분하다고 가정하자. 이 경우 한 작업이 입출력 완료를 대기해야 할 때, 처리기는 입출력을 대기할 것 같지 않은 다른 작업으로 제어를 넘긴다. 이러한 방식으로 프로그램들이 입출력 대기에 들어간 틈을 이용해 돌아가며 실행시키는 것을 **멀티프로그래밍(multiprogramming)** 또는 멀티태스킹이라 하며, 현재 널리 사용되고 있는 운여에제에서 채택된 주요 기능이다.

    ![멀티 프로그래밍 예](C:\Users\SH.C\Desktop\운영체제\멀티 프로그래밍 예.png)

    *멀티 프로그래밍의 예*

    멀티프로그래밍 운영체제는 단일프로그래밍 시스템에 비해 상당히 복잡하다. 다수의 작업이 수행될 준비가 되어 있기 위해서는 그들 모두가 주기억장치에 상주해야 하는데, 이는 어떤 형태든 **메모리 관리**를 요구한다. 또한 다수의 작업이 수행 준비 상태이면 처리기가 그 중엣거 어떤 것을 수행할 지 결정해야 하는데, 이를 위해 **스케줄링 알고리즘**이 요구된다.

  - **시분할 시스템(Time-Sharing System)**: 멀티프로그래밍을 이용하면 상당히 효율적인 일괄처리가 가능하다. 그러나 많은 작업의 경우 사용자와 컴퓨터 간의 직접 대화 모드를 제공하는 것이 좋다. 멀티프로그래밍을 통해 처리기가 다수의 일괄처리 작업을 동시에 처리할 수 있는 것과 마찬가지로, 다수의 대화형 작업을 처리할 때도 멀티프로그래밍이 사용될 수 있다. 대화형 멀티프로그래밍을 **시분할(time sharing)** 기법이라 하는데, 그 이유는 다수의 사용자가 처리기 시간을 공유하기 때문이다. 시분할 시스템에서는 각 사용자 프로그램이 짧은 시간 동안 번갈아 수행되도록 해주는 운영체제를 통해, 다수의 사용자가 터미널을 이용하여 동시에 시스템에 접근할 수 있다.

    시분할과 멀티프로그래밍은 운영체제가 해결해야 할 많은 새로운 문제를 제기하였다. 여러 작업이 메모리에 동시에 적재되어 있는 경우, 한 작업이 다른 작업의 데이터를 간섭하지 못하도록 각 작업은 다른 작업으로부터 보호되어야 한다. 그리고 대화형 사용자가 다수인 경우 오직 접근 권한을 가진 사용자들만이 특정 파일에 접근할 수 있도록 파일 시스템이 보호되어야 한다. 프린터나 대용량 저장장치와 같은 공유 자원이 동시에 요구되는 경우 접근 순서를 조정해주는 기능도 제공되어야 한다.

- 주요 성과: 운영체제는 이제까지 개발된 가장 복잡한 소프트웨어 중의 하나이다. 그 이유는 편리성, 효율성, 앞으로의 발전 능력과 같이 해결하기 어려우면서도 서로 상충되는 목적을 만족시켜야 하기 때문이다. 운영체제의 발전 과정에서 이루어진 네 가지 이론적 주요 진전은 다음과 같다.
  - 프로세스
  - 메모리 관리
  - 정보 보호 및 보안
  - 스케줄링 및 자원 관리


- 최근 운영체제로의 발전: (추후 업데이트 예정)