## 3. 쓰레드

### (1) 프로세스와 쓰레드
쓰레드에 대한 이해를 위해서는 프로세스의 자원 소유권과 스케줄링/수행이라는 두 가지 특성을 포함한다.
**자원 소유권**은 주기억장치, 입출력 채널, 이불력 장치, 파일과 같은 자원들에 대한 제어와 소유권을 프로세스에 할당할 수 있다는 개념이다.
**스케줄링/수행**은 프로세스는 수행 상태(수행, 준비 등)와 디스패칭 우선순위를 가지며, 운영체제에 의해 스케줄되고 디스패치되는 개체라는 개념이다.
이러한 두 가지 특성은 서로 독립적이며, 운영체제에 의해서 독립적으로 취급된다. 디스패칭단위는 쓰레드이고 자원 소유권 단위는 프로세스이다.

 - **멀티쓰레딩(Multi Threading)**: 운영체제가 하나의 프로세스 내에서 수행되는 여러 개의 쓰레드를 지원하는 기능을 말한다.
 멀티쓰레드 환경에서 프로세스는 보호의 단위와 자원할당의 단위로 정의되며, 다음과 같은 특징을 가진다.
   - 프로세스는 이미지를 유지하는 가상주소 공간을 가진다. 
   - 처리기와 다른 프로세스, 파일, 입출력 자원에 대한 접근제어를 지닌다.
   
   프로세스는 하나 이상의 쓰레드를 가지며, 각 쓰레드는 다음 특징들을 지닌다.
   - 쓰레드 수행 상태
   - 수행 중이 아닐 때 저장되어 있는 쓰레드 문맥(프로세스 내부에서 동작하는 독립된 프로그램 카운터)
   - 수행 스택
   - 지역 변수 저장을 위해 각 쓰레드가 사용하는 어떤 정적 저장소
   - 메모리 및 자원은 프로세스 내의 모든 쓰레드에 의해 공유
   
   단일 쓰레드 프로세스 모델에서 프로세스는 프로세스 제어블록, 사용자 주소공간, 사용자 스택과 커널 스택 등으로 표현된다.
   스택은 프로세스 수행 중에 함수 호출/복귀 행위를 관리한다.
   멀티쓰레드 환경에서는 각 쓰레드마다 별도의 스택이 있다. 그리고 레지스터 값, 우선순위 등 그 외의 쓰레드 관련 상태 정보를 포함하고 있는 별도의 제어블록이 있다.
   
   ![단일쓰레드vs멀티쓰레드](https://user-images.githubusercontent.com/56579239/156018775-5cc70911-3c5d-454c-ac1b-bc013b7f966c.png)
   
   따라서 프로세스 내의 모든 쓰레드들은 그 프로세스의 상태와 자원을 공유한다. 그 쓰레드들은 같은 주소 공간에 존재하며, 동일한 데이터를 접근한다.
   프로세스 내의 한 쓰레드가 메모리에 있는 데이터 항목을 변경했을 경우, 다른 쓰레드도 그 데이터 항목에 접근하여 그 결과를 확인할 수 있다.
   
   성능 면에서 쓰레드의 주된 장점을 다음과 같이 설명할 수 있다.
   - 새로운 프로세스를 생성하는 시간보다 기존 프로세스 내에서 새로운 쓰레드를 생성하는 시간이 더 짧다.
   - 프로세스 종료시간보다 쓰레드 종료시간이 더 짧다.
   - 프로세스들 간 교환보다 같으 프로세스에 있는 두 쓰레드 간 교환이 효율적이다.
   - 쓰레드는 서로 다른 수행 프로그램 간 통신에서도 효율적이다. (커널 개입이 필요 없다.)
   
   따라서 연관된 수행단위의 집합으로 구현되어야 하는 응용이나 기능이 있다면 이들을 독립적인 프로세스가 아닌 쓰레드의 모음으로 구현하는 것이 훨씬 효율적이다.
   여러 가지 다른 기능을 수행하는 특정 프로그램의 구조를 단순화 할 수 있다는 면에서 쓰레드 구조는 단일 처리기에서도 유용하다.
   
   단일 사용자 멀티 프로세싱 시스템에서 사용하는 네 가지 예
   - **전면(foreground)과 후면(background) 작업**: 프로그램에서 이전 명령이 완료되기 전에 다음 명령을 신속하게 수행함으로써 응용의 속도를 향상시킨다.
   - **비동기(asynchronous) 처리**
   - **빠른 수행**: 한 쓰레드가 블록 될지라도 다른 쓰레드가 수행될 수 있다.
   - **모듈 프로그램 구조**: 다양한 활동에 대한 다양한 출발, 목적지를 포함하는 프로그램의 경우, 쓰레드를 사용하여 설계하고 구현하는 것이 편리하다.
   
- **쓰레드 기능**: 프로세스처럼 쓰레드도 수행 상태를 가지며 서로 동기화 될 수 있다.

   - 쓰레드 상태: 프로세스 상태와 같이 쓰레드의 주요 상태에는 수행과 준비, 블록이 있다.
   일반적으로 보류 상태는 프로세스 수준의 개념이기 때문에 쓰레드와 연관시키는 것은 의미가 없다.
   특히 프로세스가 주기억장치로부터 스왑아웃될 경우, 그 프로세스의 모든 쓰레드는 주소 공간을 공유하기 때문에 모든 쓰레드도 반드시 스왑아웃된다.
   
   쓰레드 상태 전이와 관련하여 기본적으로 네 가지의 쓰레드 연산이 있다.
   
     - **생성(Spawn)**: 일반적으로 프로세스가 생성되면 이 프로세스를 위한 쓰레드도 함께 생성된다. 계속해서 그 쓰레드는 프로세스 내에서 다른 쓸데르르 생성할 수 있다.
     - **블록(Block)**: 쓰레드가 어떤 사건을 기다려야 할 때 쓰레드는 블록된다.
     - **비블록(Unblock)**: 쓰레드가 블록되어 기다리던 사건이 발생되었을 때 그 쓰레드는 준비 큐로 이동한다.
     - **종료(Finish)**: 쓰레드가 작업을 완료하면 레지스터 문맥과 스택이 해제된다.
   
   ![단일 처리기 상에서 멀티쓰레딩 예](https://user-images.githubusercontent.com/56579239/156018831-4b47a42f-b81e-4257-942a-0035d23b0e56.png)
   ![쓰레드를 사용한 원격 프로시저 호출](https://user-images.githubusercontent.com/56579239/156018842-1ed8966d-6040-47b2-a9ce-9cb2c7ba318b.png)
   
   여기서 주요 논점은 한 쓰레드의 블록이 전체 프로세스를 블록시키는지 여부이다. 하나의 쓰레드가 전체 프로세스를 블록시킨다면 쓰레드가 지닌 장점과 유연성이 사라진다.
   
   - 쓰레드 동기화: 프로세스 내의 모든 쓰레드는 주소공간과 열린 파일과 같은 자원을 공유한다. 
   하나의 쓰레드에 의한 자원의 변경은같은 프로세스 내에 존재하는 모든 쓰레드의 환경에 영향을 미친다.
   따라서 쓰레드들이 서로 간섭하지 않고 자료구조를 손상시키지 않도록 쓰레드들의 행위를 동기화하는 것이 필요하다.
 

### (2) 쓰레드의 유형
  
  - **사용자 수준 쓰레드(User Level Thread)와 커널 수준 쓰레드(Kunel Level Thread)**
  
    - 사용자 수준 스레드(ULT): 순수한 ULT 구현에서 쓰레드 관리와 관계된 모든 일은 응용이 수행하며 커널은 쓰레드의 존재를 알지 못 한다.
    ULT 관리 루틴들로 구성된 패키지인 쓰레드 라이브러리를 이용하여 모든 응용을 멀티쓰레드 기반으로 프로그래밍할 수 있다.
    쓰레드 라이브러리는 쓰레드의 생성과 제거, 쓰레드 간의 메시지와 데이터 전달, 쓰레드 수행의 스케줄링, 쓰레드 문맥의 저장과 복구 등을 위한 코드를 포함한다.
    
    KLT 대신 ULT를 사용하면 다음과 같은 장점이 있다.
      - 쓰레드 관리를 위한 모든 자료구조가 프로세스의 사용자 주소 공간에 있기 때문에 쓰레드 교환에 커널 모드의 권한이 요구되지 않는다. 
      그러므로 커널 모드로의 전환이 없어 오버헤드를 절감시켜 준다.
      - 스케줄링이 응용에 맞게 구성될 수 있다. 운영체제 스케줄러에 영향을 및치지 않고, 스케줄링 알고리즘을 응용에 맞출 수 있다.
      - ULT는 어떤 응용체제에서도 적용될 수 있다.
    
    KLT와 비교하여 ULT는 아래의 두 가지 단점을 가진다.
      - 일반 운영체제에서 대부분의 시스템 호출은 해당 쓰레드를 블록시킨다. 결과적으로 같은 프로세스 내에 있는 모든 쓰레드가 블록된다.
      - 순수한 ULT 기반의 멀티쓰레드 응용은 멀티프로세싱의 장점을 살릴 수 없다.
    위 두 문제를 해결하기 위해 응용을 멀티쓰레드 대신 멀티프로세스로 작성함으로써 문제를 해결할 수 있다. 그러나 이러한 시도는 쓰레드의 장점을 살리지 못 한다.
    
    - 커널 수준 쓰레드(KLT): 순수한 KLT 구현에서는 쓰레드 관리와 관련된 모든 작업이 커널에 의해 이루어진다. 응용에서는 쓰레드를 관리하는 코드가 없고 단순히 API가 있다.
    Windows가 이런 예이다. 커널은 전체 프로세스에 대한 문맥 정보 및 각 프로세스 내 쓰레드에 대한 문맥 정보를 유지한다. 커널에 의한 스케줄링은 쓰레드를 기반으로 해서 이루어진다.
    이러한 접근 방법을 사용하여 ULT의 주된 두 가지 단점을 극복하였다.
    
    첫째, 커널은 여러 처리기에게 같은 프로세스 내의 여러 쓰레드를 동시에 스케줄 할 수 있다. 둘째, 한 프로세스의 쓰레드가 블록되면 커널은 같은 프로세스에서 다른 쓰레드를 스케줄 할 수 있다.
    KLT의 다른 장점은 커널 루틴 자체가 멀티쓰레드로 구성될 수 있다는 것이다.
    
    ULT와 비교할 때 KLT의 주된 장점은 커널로의 모드 전환이 필요하다는 것이다. 
    모드 전환으로 인한 오버헤드에 대해 알아보면, 아래 표로 알 수 있듯이 단일 쓰레드 프로세스와 비교해 볼 때 KLT 멀티 쓰레드를 이용함으로써 속도 향상이 가능하고 ULT를 이용하면
    추가적인 속도 향상이 가능하다. 그러나 실제로 추가적인 속도 향상이 실현될 지 여부는 응용의 특성에 달려있다. 만일 응용에서 대부분의 쓰레드 교환이 커널을 요구한다면
    ULT 기반으로 하는 구조는 KTL 구조보다 훨씬 좋은 성능을 내지 못 할 수도 있다.
    
   ![쓰레드와 프로세스 간의 관계](https://user-images.githubusercontent.com/56579239/156019260-3c0eafab-2c82-48df-962e-1ec1c65ca5d3.png)
   
    - 결합된 접근 방법: 어떤 운영체제는 ULT와 KLT 구현이 결합된 형태를 제공한다. 결합된 방법을 적용하는 시스템에서 쓰레드 생성은 완전히 사용자 공간에서 이루어지며,
    한 용응 내의 쓰레드들에 대한 스케줄링 및 동기화도 대부분 사용자 공간에서 이루어진다. 한 응용의 ULT들은 그보다 적거나 같은 수의 KLT에 사상된다.
    결합된 접근 방법에서는 한 응용의 쓰레드들이 다수의 처리기에서 병렬로 수행될 수 있고, 블록형 시스템 호출이 전체 프로세스를 블록시키지 않는다.
  
### (3) 멀티코어와 멀티쓰레딩
  여러 개의 쓰레드로 구성된 하나의 응용프로그램을 지원하기 위해서 멀티코어 시스템을 사용하는 것은 성능과 응용 프로그램 설계에 대한 여러 이슈들을 포함한다.
  
  - 멀티코어 상에서의 소프트웨어 성능
  멀티코어 구조의 잠재적인 성능 향상은 응용이 이용 가능한 병렬 자원을 효율적으로 이용할 수 있는 능력에 영향을 받는다. Amdahl의 법칙에 따르면 
  
   ![Amdahl의 법칙](https://user-images.githubusercontent.com/56579239/156018899-db411349-10a4-4b0c-b5d4-d8e7b9789c47.png)
   
  멀티코어의 성능에 영향을 받는 응용의 예는 다음과 같다. 
    - **멀티 쓰레드화된 네이티브 응용*: 멀티쓰레드화된 응용은 소수의 고도로 쓰레드화된 프로세스를 갖는 특징이 있다.
    - **멀티 프로세스 응용**: 멀티 프로세스 응용은 다수의 단일 쓰레드화된 프로세스들이 존재하는 특징이 있다.
    - **자바 응용**: 자바 응용은 근본적인 방식으로 쓰레딩을 포함하고 있다. 자바 언어가 멀티쓰레드화된 응용을 개발하는데 매우 용이할 뿐만 아니라 자바 가상 머신도
    자바 응용에 대한 스케줄링과 메모리 관리를 지원하는 멀티쓰레드화된 프로세스이다.
    - **멀티인스턴스 응용**: 개별적인 응용이 많은 수의 쓰레드를 사용해서 속도를 향상시키지 못할지라도 
    다수의 응용 인스턴스를 멀티코어 구조 상에서 병렬적으로 실행함으로써 속도를 향상 시킬 수 있다.
  
