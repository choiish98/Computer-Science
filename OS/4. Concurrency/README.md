## 4-1. 병행성: 상호배제와 동기화
운영체제 설계의 핵심 주제는 모두 프로세스와 쓰레드의 관리와 연관되어 있으며, 대표적으로 다음과 같은 것이 있다.
- **멀티프로그래밍**
- **멀티프로세싱**
- **분산처리**
  
이러한 모든 분야와 운영체제 설계의 핵심은 **병행성(concurrency)** 이다. 병행성은 프로세스 간 통신, 자원에 대한 공유와 경쟁, 프로세스 활동들의 동기화, 프로세스에 대한 처리기
할당 시간 등 다양한 이슈들을 포함한다. 병행성은 다음과 같은 세 가지 문맥에서 발생한다.

- 다수의 응용: 다수의 활동 중인 응용들 간에 처리 시간의 동적 공유를 위해 멀티프로그래밍이 개발되었다.
- 구조화된 응용: 모듈화된 설계 원칙과 구조적 프로그래밍의 발전으로 일부 응용들은 병행 프로세스들의 집합으로 구현된다.
- 운영체제 구조: 운영체제도 다수의 프로세스와 쓰레드의 집합으로 구현된다.

### (1) 병행성의 원리
인터리빙과 오버래핑은 서로 다른 문제를 야기하는 것처럼 보인다. 하지만 두 기법은 모두 병행처리의 예이며, 서로 동일한 문제를 야기한다.
단일처리기 시스템의 경우 프로세스들의 수행 상대 속도를 예측할 수 없다는 특징에서 발생한다.
프로세스들이 수행되는 상대 속도는 운영체제의 스케줄링 정책과 다른 프로세스들의 활동과 운영체제가 인터럽트 처리하는 방법 등에 따라 동적으로 변한다.
이렇듯 동적으로 변하는 특징은 프로그램 개발 시에 다음과 같은 어려움을 야기한다.
- 전역 자원의 공유에 어려움
- 운영체제가 자원을 최적으로 할당하기 어려워 진다. (교착 상태)
- 프로그래밍 오류를 찾아내는 것이 어려워 진다. (실행 순서에 따라 오류가 나타나지 않을 수 있다)
  
이와 같은 어려움은 멀티프로세서 시스템에서도 발생한다. 멀티프로세서 시스템에서도 프로세스들에 대한 수행의 상대 속도를 예측할 수 없기 때문이다.

- **경쟁 상태**: 다수의 프로세스나 쓰레드가 공유 자원을 동시에 읽거나 쓰려고 하는 상태를 경쟁 상태라고 한다. 
  경쟁 상태가 발생하면 최종 수행 결과는 프로세스들의 수행 순서에 따라 달라진다.
  
- 프로세스 간 상호 작용: 프로세스들이 서로 어떤 방법으로 상호작용하는가는 다른 프로세스들의 존재에 대하여 어느 정도로 인식하고 있는지를 기준으로 분류할 수 있다.
  
 ![프로세스 상호 작용](https://user-images.githubusercontent.com/56579239/156125573-cb9e2899-ef74-43bf-aac7-d5c59abb6d1c.png)

  
실제 프로세스들의 관계와 사호작용은 명확하게 구분되지 않는다. 오히려, 대부분의 프로세스들은 경쟁과 협력의 상호작용으로 보인다.
하지만 발생하는 문제와 의미를 명확하기 위해 서로 구분 하도록 하자.
 
  - 자원에 대한 프로세스 간 경쟁: 두 개 이상의 프로세스들이 수행 중에 특정 자원을 사용하려 한다. 각 프로세스는 다른 프로세스들의 존재를 모른다.
  또한 각 프로세스는 다른 프로세스의 수행 결과에 영향을 받지 않아야 한다. 따라서 각 프로세스는 사용한 자원의 상태를 변화시켜서는 안된다.
  경쟁 관계에 있는 프로세스들이 존재하는 경우 **상호 배제**, 교착 상태, 기아 라는 세 가지 제어 문제가 발생한다.
  
    두 개 이상의 프로세스가 동시에 사용할 수 없는 자원을 **임계 자원(critial resource)** 라고 하며, 그 자원을 접근하는 프로그램 일부분을 **임계 영역(critical section)** 이라고 한다.
    (만약 프린터에 대한 임계 영역에 두 가지 프로세스가 동시에 접근한다면, A4 용지에 두 가지 출력이 섞여 출력될 수 있다.)
    상호 배제란 한 시점에 단 하나의 프로세스만이 임계영역에 들어갈 수 있다는 것을 의미한다.
  
    일반적으로 상호배제란 프로그래머가 직접 작성한다. 상호배제의 구체적인 내용은 프로그램마다 다르며, 운영체제가 구체적인 요구 조건을 명확하게 파악하기 어렵기 때문이다.
    상호 배제의 보장은 **교착 상태**와 기아라는 제어 문제를 발생시킨다. 교착 상태는 서로 다른 프로세스가 자원을 사용하기 위해 서로의 종료 조건을 기다리는 상태를 뜻한다. 
    각 프로세스들은 사용하고자 하는 자원을 할당받기 위하여 기다린다. 그러나 서로 상대방이 자원을 제공해 줄 때까지 기다릴 뿐, 자신이 할당받은 자원은 반납하지 않는다.
    따라서 두 프로세스는 서로 대기만 할 뿐 더 이상 수행을 하지 못 한다.
  
    마지막 제어 문제는 **기아**이다. 기아는 교착 상태는 아니지만 특정 프로세스가 오랜 기간 동안 자원을 사용하지 못 하는 상태이다. 
    자원에 대한 접근 경쟁에서 밀려 무한히 대기하는 상태를 뜻한다.
    
  - 공유를 이용한 프로세스 간 협력: 공유를 이용한 프로세스 간 협력에서 프로세스들은 서로를 명시적으로 알지는 못하면서도 서로 상호작용을 한다.
  프로세스는 공유 데이터를 읽거나 갱신한다. 이때 다른 프로세스들도 같은 공유 변수를 접근할 수 있다. 따라서 프로세스들은 공유하는 데이터가 적절하게 관리될 수 있도록 서로 협력한다.
  협력을 위해 사용한 제어 기법을 결국 데이터 무결성을 보장하게 된다. 하지만 공유되는 데이터가 자원에 저장되기 때문에 결국 여기서도 제어 문제가 발생한다.
  한편 공유에 의한 협력에서는 데이터에 일관성 유지라는 조건 또한 요구된다.
  
  - 통신을 이용한 프로세스 간 협력: 모든 프로세스들이 서로를 인식한다. 즉, 모든 프로세스들이 공통의 목표를 위해 연결되어 있으며, 
  이때 통신은 프로세스 간 동기화와 협력 그리고 다양한 공통 행위를 수행할 때 사용된다.
  통신은 특정 유형의 메시지들로 구성된다. 프로그래밍 언어나 운영체제는 메시지를 보내거나 받을 수 있는 프리미티브를 제공한다.
  메시지를 주고 받을 때, 프로세스들 사이에 실제로 공유되는 것은 없다. 따라서 통신의 경우 상호 배제라는 제어 문제는 발생하지 않는다.
  하지만, 교착 상태와 기아라는 문제점은 여전히 나타난다.
  
- **상호 배제 요구 조건**: 상호배제를 보장하기 위해서는 다음의 요구조건들이 만족되어야 한다.
  - 프로세스는 상호 배제가 강제되어야 한다. (단 하나의 프로세스만이 임계영역에 진입 가능)
  - 다른 프로세스의 수행을 간섭해서는 안된다.
  - 임계 영역에 접근하려는 프로세스의 수행이 무한히 미루어져서는 안 된다. (교착 및 기아 발생 x)
  - 임계 영역이 비어있을 때, 임계 영역에 접근하려는 프로세스는 즉시 임계 영역에 들어갈 수 있어야 한다.
 
상호 배제의 요구 조건을 만족시키는 방법은 여러 가지가 있다. 그 중 한 가지 방법은 모든 책임을 병행 수행하려는 프로세스들이 담당하는 것이다.
즉 프로그래밍 언어나 운영체제의 지원 없이 프로세스 간 협력을 통해 직접 상호 배제를 보장하는 것이다. 이 방법을 소프트웨어적인 접근 방법이라 부른다.
수행 부하가 크고 잘 설계되지 않을 경우 오동작의 간으성도 높지만 병행 처리의 복잡도와 상호 배제 원리를 더욱 잘 이해하기 위해 알아두면 좋다.
두 번째 접근 방법은 특별한 용도로 설계된 기계어를 사용하는 것이다. 범용 해결 방법에 비해 덜 매력적이지만 부하가 적다는 장점이 있다.
세 번째 접근 방법은 운영체제나 프로그래밍 언어 수준에서 상호 배제 보장을 제공하는 것이다.

### (2) 상호 배제: 하드웨어 지원
- **인터럽트 금지**: 인터럽트가 발생하지 않으면 그 동안은 한 프로세스의 계속적인 실행을 보장할 수 있다. 
그러므로 상호 배제를 보장하기 위한 가장 간단한 방법은 프로세스가 인터럽트 되지 않도록 하는 것이다.
하지만 인터럽트가 불허되면 외부 이벤트에 대한 처리와 다른 프로세스에 대한 스케줄링 등 모든 기능이 중지되기 때문에 수행 효율이 눈에 띄게 감소할 것이다.
또한, 멀티 프로세서 시스템에서는 인터럽트가 금지된 상황에서도 서로 다른 프로세스가 공유 자원을 동시에 접근할 수 있기 때문에 올바르게 상호배제를 보장할 수 없다는 것이다.

- **특별한 기계 명령어**: 하드웨어 수준에서는 특정 메모리 주소가 접근디고 있을 때 같은 위치에 대한 다른 접근 요청은 차단된다. 이를 기반으로 처리기 설계자들은 두 개의 기능을
원자적으로 처리하는 다양한 기계어를 제안하였다.

  - **Compare&Swap 명령어**
  
  ```
  int compare_and_swap (int *word, int testval, int newval)
  {
    int oldval;
    oldval = *word;
    if (oldval == testval) *word = newval;
    return oldval;
  }
  ```
  compare&swap 함수는 원자적으로 수행되며, 중간에 중단되는 경우는 없다. 이 명령은 거의 모든 처리기에서 지원하며, 대부분의 운영체제에서 병행성
  지원을 위해 사용한다. 임계영역에 이미 프로세스가 존재하고 있을 때, 임계영역에 진입하려는 다른 프로세스들은 대기하게 된다.
  이때 임계영역에 들어가기 위해 테스트를 반복 실행하는 것을 **바쁜 대기**라고 한다.
    
  - **Exchange 명령어**
  
  ```
  int exchange (int *register, int *memory)
  {
    int temp;
    temp = *memory;
    *memory = *register;
    *register = temp;
  }
  ```
  
  - 기계 명령어 접근 방법의 특성
  
    장점
    - 멀티프로세서 시스템에서도 사용 가능하다
    - 간단하고 검증이 쉽다.
    - 여러 개의 임계 영역을 지원한다
    
    단점
    - 바쁜 대기를 사용한다.
    - 기아가 발생할 수 있다.
    - 교착 상태에 빠질 수 있다.
  
### (3) 세마포어
세마포어는 Dijkstra 기법을 이용한 시그널 구조의 방법이다. 기본적인 원리는 두 개 이상의 프로세스들은 간단한 형태의 시그널을 이용해 협동할 수 있다.
이 때 사용하는 시그널을 **세마포어**라고 한다. 세마포어는 정수 값을 가지는 변수로 볼 수 있으며, 다음 세 가지 연산으로 접근할 수 있다.

- 세마포어 초기화
- semWait 연산: 세마포어 값을 감소시키고 호출한 프로세스는 블록된다.
- semSignal 연산: 세마포어 값을 증가시키고 블록된 프로세스를 깨운다.

세마포어는 다음과 같은 3가지 문제점이 있다.
- 프로세스가 세마포어를 감소시키기 전까지는 그 프로세스가 블록될 지 안 될지 모른다.
- 프로세스가 세마포어를 증가시키고 블록되어 있던 프로세스를 깨우면, 이 두 프로세스 모두 수행 가능 상태가 된다. 그리고 누가 먼저 수행될 지 알 수 없다.
- 세마포어에 시그널을 보낼 때, 우리는 다른 프로세스가 대기 중인지 여부를 알 필요가 없다.

semWait와 semSignal 프리미티브는 원자적으로 수행된다. 각 프리미티브가 수행되면 완료될 때까지 중간에 다른 프로세스가 끼어들 수 없다.
세마포어는 유지할 수 있는 값의 범위에 따라 이진 세마포어와 범용 세마포어로 구분된다. 이진 세마포어는 범용 세마포어에 비해 구현하기 쉽다. 
또한 표현력에 있어서도 범용 세마포어와 동일한 능력을 갖는다. (비이진 세마포어를 **카운팅 세마포어**라 한다.)
이진 세마포어와 관련된 개념으로 **mutex**가 있는데 차이점은 세마포어의 경우 락을 설정한 프로세스와 해제하는 프로세스가 다를 수 있다.
하지만 mutex는 락을 설정한 프로세스와 해제하는 프로세스가 반드시 같아야 한다.

세마포어에서 블록된 프로세스들을 관리하기 위해 큐를 이용한다. 이때 큐에 연결된 프로세스들이 여러 개 있을 때 어떤 프로세스를 먼저 수행해야하는 지의 문제가 있다.
가장 공정한 정책은 선입선출인데 이를 이용하는 방식이 **강성 세마포어**이다. 반면 큐에서 제거되는 순서를 특별히 명시하지 않는 방식을 **약성 세마포어**라 한다.
강성 세마포어에서는 기아상태가 발생하지 않는데 약성 세마포어에서는 발생할 수 있따. 또한 강성 세마포어는 직관적이며 구현하기도 편리하고 실제로 많은 운영체제에서도 사용한다.

- **상호 배제**
프로세스가 공유 자원을 접근하려는 코드 부분이 임계영역으로 정의된다. 임계영역에 들어가기 직전에 semWait(s)를 호출한다. 만약 세마포어의 s 값이 양수가 아니라면, 프로세스는 블록된다.
만일 세마포어의 s 값이 1이라면, 1만큼 감소시킨 후 임계영역에 들어간다. 이제는 세마포어의 값이 양수가 아니며, 다른 프로세스들은 임계영역에 진입할 수 없다.
이런 방식으로 한 순간에 하나의 프로세스만 임계영역에 들어갈 수 있게 되며, 상호 배제가 보장된다.

- **생산자 소비자 문제**
데이터를 만드는 생산자 프로세스와 데이터를 소비하는 소비자 프로세스가 존재한다. 생산자는 하나 또는 그 이상의 데이터를 생성하고 버퍼에 저장한다.
소비자는 한 번에 하나씩 버퍼에서 데이터를 꺼내 소비한다. 이때 버퍼 접근이 중첩되어서는 안된다. 또한 버퍼가 가득차면 생산자는 더 이상 버퍼에 추가할 수 없으며,
버퍼가 비어 있으면 소비자도 꺼내 갈 수 없도록 제어해야 한다. 이런 버퍼 문제를 해결하는 간단한 방법은 상호 배제를 위해 semWait 함수와 semSignal 함수를 이용하는 것이다.

하지만 이 프로그램은 소비자가 버퍼의 데이터를 모두 소진하면 생산자의 생산이 있을 때까지 세마포어 delay에 대기해야하는 문제가 있다.
이 문제를 해결하기 위해 조건 문을 임계역역 내로 옮기는 것을 고려할 수 있지만 이는 교착 상태를 일으킬 수 있다.
또 다른 방법으로는 임계영역 내에 보조 변수를 사용하는 것인데 보다 깔끔한 방법은 범용 세마포어를 이용하는 것이다.

- 세마포어 구현
semWait와 semSignal 연산은 반드시 원자적으로 구현되어야 한다. 상호 배제를 보장하면서 이를 범용 세마포어로 구현하기 위한 방법으로 인터럽트 금지 등과 같은 하드웨어 지원을 사용하는 방법이다.
compare&swap 명령어를 이용하여 semWait와 semSignal 연산을 구현하였을 경우, 바쁜 대기 방식이지만 수행 시간이 비교적 짧기 때문에 길지 않게 대기할 수 있다.

```
const int sizeofbuffer = /* buffer size */;
semaphore s = 1, n = 0, e = sizeofbuffer;
void producer()
{
  while (true) {
    produce();
    semWait(e);
    semWait(s);
    append();
    semsignal(s);
    semSignal(n);
  }
}
void consumer() 
{ 
  while (true) {
    semWait(n);
    semWait(s);
    take();
    semSignal(s);
    semSignal(e);
    consume();
  }
}
void main()
{
  parbegin (producer, consumer);
}
```

