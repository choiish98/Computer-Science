## 4-1. 병행성
운영체제 설계의 핵심 주제는 모두 프로세스와 쓰레드의 관리와 연관되어 있으며, 대표적으로 다음과 같은 것이 있다.
- **멀티프로그래밍**
- **멀티프로세싱**
- **분산처리**
  
이러한 모든 분야와 운영체제 설계의 핵심은 **병행성(concurrency)** 이다. 병행성은 프로세스 간 통신, 자원에 대한 공유와 경쟁, 프로세스 활동들의 동기화, 프로세스에 대한 처리기
할당 시간 등 다양한 이슈들을 포함한다. 병행성은 다음과 같은 세 가지 문맥에서 발생한다.

- 다수의 응용: 다수의 활동 중인 응용들 간에 처리 시간의 동적 공유를 위해 멀티프로그래밍이 개발되었다.
- 구조화된 응용: 모듈화된 설계 원칙과 구조적 프로그래밍의 발전으로 일부 응용들은 병행 프로세스들의 집합으로 구현된다.
- 운영체제 구조: 운영체제도 다수의 프로세스와 쓰레드의 집합으로 구현된다.

### (1) 병행성의 원리
인터리빙과 오버래핑은 서로 다른 문제를 야기하는 것처럼 보인다. 하지만 두 기법은 모두 병행처리의 예이며, 서로 동일한 문제를 야기한다.
단일처리기 시스템의 경우 프로세스들의 수행 상대 속도를 예측할 수 없다는 특징에서 발생한다.
프로세스들이 수행되는 상대 속도는 운영체제의 스케줄링 정책과 다른 프로세스들의 활동과 운영체제가 인터럽트 처리하는 방법 등에 따라 동적으로 변한다.
이렇듯 동적으로 변하는 특징은 프로그램 개발 시에 다음과 같은 어려움을 야기한다.
- 전역 자원의 공유에 어려움
- 운영체제가 자원을 최적으로 할당하기 어려워 진다. (교착 상태)
- 프로그래밍 오류를 찾아내는 것이 어려워 진다. (실행 순서에 따라 오류가 나타나지 않을 수 있다)
  
이와 같은 어려움은 멀티프로세서 시스템에서도 발생한다. 멀티프로세서 시스템에서도 프로세스들에 대한 수행의 상대 속도를 예측할 수 없기 때문이다.

- **경쟁 상태**: 다수의 프로세스나 쓰레드가 공유 자원을 동시에 읽거나 쓰려고 하는 상태를 경쟁 상태라고 한다. 
  경쟁 상태가 발생하면 최종 수행 결과는 프로세스들의 수행 순서에 따라 달라진다.
  
- 프로세스 간 상호 작용: 프로세스들이 서로 어떤 방법으로 상호작용하는가는 다른 프로세스들의 존재에 대하여 어느 정도로 인식하고 있는지를 기준으로 분류할 수 있다.
  
 ![프로세스 상호 작용](https://user-images.githubusercontent.com/56579239/156125573-cb9e2899-ef74-43bf-aac7-d5c59abb6d1c.png)

  
실제 프로세스들의 관계와 사호작용은 명확하게 구분되지 않는다. 오히려, 대부분의 프로세스들은 경쟁과 협력의 상호작용으로 보인다.
하지만 발생하는 문제와 의미를 명확하기 위해 서로 구분 하도록 하자.
 
  - 자원에 대한 프로세스 간 경쟁: 두 개 이상의 프로세스들이 수행 중에 특정 자원을 사용하려 한다. 각 프로세스는 다른 프로세스들의 존재를 모른다.
  또한 각 프로세스는 다른 프로세스의 수행 결과에 영향을 받지 않아야 한다. 따라서 각 프로세스는 사용한 자원의 상태를 변화시켜서는 안된다.
  경쟁 관계에 있는 프로세스들이 존재하는 경우 **상호 배제**, 교착 상태, 기아 라는 세 가지 제어 문제가 발생한다.
  
    두 개 이상의 프로세스가 동시에 사용할 수 없는 자원을 **임계 자원(critial resource)** 라고 하며, 그 자원을 접근하는 프로그램 일부분을 **임계 영역(critical section)** 이라고 한다.
    (만약 프린터에 대한 임계 영역에 두 가지 프로세스가 동시에 접근한다면, A4 용지에 두 가지 출력이 섞여 출력될 수 있다.)
    상호 배제란 한 시점에 단 하나의 프로세스만이 임계영역에 들어갈 수 있다는 것을 의미한다.
  
    일반적으로 상호배제란 프로그래머가 직접 작성한다. 상호배제의 구체적인 내용은 프로그램마다 다르며, 운영체제가 구체적인 요구 조건을 명확하게 파악하기 어렵기 때문이다.
    상호 배제의 보장은 **교착 상태**와 기아라는 제어 문제를 발생시킨다. 교착 상태는 서로 다른 프로세스가 자원을 사용하기 위해 서로의 종료 조건을 기다리는 상태를 뜻한다. 
    각 프로세스들은 사용하고자 하는 자원을 할당받기 위하여 기다린다. 그러나 서로 상대방이 자원을 제공해 줄 때까지 기다릴 뿐, 자신이 할당받은 자원은 반납하지 않는다.
    따라서 두 프로세스는 서로 대기만 할 뿐 더 이상 수행을 하지 못 한다.
  
    마지막 제어 문제는 **기아**이다. 기아는 교착 상태는 아니지만 특정 프로세스가 오랜 기간 동안 자원을 사용하지 못 하는 상태이다. 
    자원에 대한 접근 경쟁에서 밀려 무한히 대기하는 상태를 뜻한다.
    
  - 공유를 이용한 프로세스 간 협력: 공유를 이용한 프로세스 간 협력에서 프로세스들은 서로를 명시적으로 알지는 못하면서도 서로 상호작용을 한다.
  프로세스는 공유 데이터를 읽거나 갱신한다. 이때 다른 프로세스들도 같은 공유 변수를 접근할 수 있다. 따라서 프로세스들은 공유하는 데이터가 적절하게 관리될 수 있도록 서로 협력한다.
  협력을 위해 사용한 제어 기법을 결국 데이터 무결성을 보장하게 된다. 하지만 공유되는 데이터가 자원에 저장되기 때문에 결국 여기서도 제어 문제가 발생한다.
  한편 공유에 의한 협력에서는 데이터에 일관성 유지라는 조건 또한 요구된다.
  
  - 통신을 이용한 프로세스 간 협력: 모든 프로세스들이 서로를 인식한다. 즉, 모든 프로세스들이 공통의 목표를 위해 연결되어 있으며, 
  이때 통신은 프로세스 간 동기화와 협력 그리고 다양한 공통 행위를 수행할 때 사용된다.
  통신은 특정 유형의 메시지들로 구성된다. 프로그래밍 언어나 운영체제는 메시지를 보내거나 받을 수 있는 프리미티브를 제공한다.
  메시지를 주고 받을 때, 프로세스들 사이에 실제로 공유되는 것은 없다. 따라서 통신의 경우 상호 배제라는 제어 문제는 발생하지 않는다.
  하지만, 교착 상태와 기아라는 문제점은 여전히 나타난다.
  
- **상호 배제 요구 조건**: 상호배제를 보장하기 위해서는 다음의 요구조건들이 만족되어야 한다.
  - 프로세스는 상호 배제가 강제되어야 한다. (단 하나의 프로세스만이 임계영역에 진입 가능)
  - 다른 프로세스의 수행을 간섭해서는 안된다.
  - 임계 영역에 접근하려는 프로세스의 수행이 무한히 미루어져서는 안 된다. (교착 및 기아 발생 x)
  - 임계 영역이 비어있을 때, 임계 영역에 접근하려는 프로세스는 즉시 임계 영역에 들어갈 수 있어야 한다.
 
상호 배제의 요구 조건을 만족시키는 방법은 여러 가지가 있다. 그 중 한 가지 방법은 모든 책임을 병행 수행하려는 프로세스들이 담당하는 것이다.
즉 프로그래밍 언어나 운영체제의 지원 없이 프로세스 간 협력을 통해 직접 상호 배제를 보장하는 것이다. 이 방법을 소프트웨어적인 접근 방법이라 부른다.
수행 부하가 크고 잘 설계되지 않을 경우 오동작의 간으성도 높지만 병행 처리의 복잡도와 상호 배제 원리를 더욱 잘 이해하기 위해 알아두면 좋다.
두 번째 접근 방법은 특별한 용도로 설계된 기계어를 사용하는 것이다. 범용 해결 방법에 비해 덜 매력적이지만 부하가 적다는 장점이 있다.
세 번째 접근 방법은 운영체제나 프로그래밍 언어 수준에서 상호 배제 보장을 제공하는 것이다.

### (2) 상호 배제: 하드웨어 지원
- **인터럽트 금지**: 인터럽트가 발생하지 않으면 그 동안은 한 프로세스의 계속적인 실행을 보장할 수 있다. 
그러므로 상호 배제를 보장하기 위한 가장 간단한 방법은 프로세스가 인터럽트 되지 않도록 하는 것이다.
하지만 인터럽트가 불허되면 외부 이벤트에 대한 처리와 다른 프로세스에 대한 스케줄링 등 모든 기능이 중지되기 때문에 수행 효율이 눈에 띄게 감소할 것이다.
또한, 멀티 프로세서 시스템에서는 인터럽트가 금지된 상황에서도 서로 다른 프로세스가 공유 자원을 동시에 접근할 수 있기 때문에 올바르게 상호배제를 보장할 수 없다는 것이다.

- **특별한 기계 명령어**: 하드웨어 수준에서는 특정 메모리 주소가 접근디고 있을 때 같은 위치에 대한 다른 접근 요청은 차단된다. 이를 기반으로 처리기 설계자들은 두 개의 기능을
원자적으로 처리하는 다양한 기계어를 제안하였다.

  - **Compare&Swap 명령어**
  
  ```
  int compare_and_swap (int *word, int testval, int newval)
  {
    int oldval;
    oldval = *word;
    if (oldval == testval) *word = newval;
    return oldval;
  }
  ```
  compare&swap 함수는 원자적으로 수행되며, 중간에 중단되는 경우는 없다. 이 명령은 거의 모든 처리기에서 지원하며, 대부분의 운영체제에서 병행성
  지원을 위해 사용한다. 임계영역에 이미 프로세스가 존재하고 있을 때, 임계영역에 진입하려는 다른 프로세스들은 대기하게 된다.
  이때 임계영역에 들어가기 위해 테스트를 반복 실행하는 것을 **바쁜 대기**라고 한다.
    
  - **Exchange 명령어**
  
  ```
  int exchange (int *register, int *memory)
  {
    int temp;
    temp = *memory;
    *memory = *register;
    *register = temp;
  }
  ```
  
  - 기계 명령어 접근 방법의 특성
  
    장점
    - 멀티프로세서 시스템에서도 사용 가능하다
    - 간단하고 검증이 쉽다.
    - 여러 개의 임계 영역을 지원한다
    
    단점
    - 바쁜 대기를 사용한다.
    - 기아가 발생할 수 있다.
    - 교착 상태에 빠질 수 있다.
  
### (3) 세마포어
세마포어는 Dijkstra 기법을 이용한 시그널 구조의 방법이다. 기본적인 원리는 두 개 이상의 프로세스들은 간단한 형태의 시그널을 이용해 협동할 수 있다.
이 때 사용하는 시그널을 **세마포어**라고 한다. 세마포어는 정수 값을 가지는 변수로 볼 수 있으며, 다음 세 가지 연산으로 접근할 수 있다.

- 세마포어 초기화
- semWait 연산: 세마포어 값을 감소시키고 호출한 프로세스는 블록된다.
- semSignal 연산: 세마포어 값을 증가시키고 블록된 프로세스를 깨운다.

세마포어는 다음과 같은 3가지 문제점이 있다.
- 프로세스가 세마포어를 감소시키기 전까지는 그 프로세스가 블록될 지 안 될지 모른다.
- 프로세스가 세마포어를 증가시키고 블록되어 있던 프로세스를 깨우면, 이 두 프로세스 모두 수행 가능 상태가 된다. 그리고 누가 먼저 수행될 지 알 수 없다.
- 세마포어에 시그널을 보낼 때, 우리는 다른 프로세스가 대기 중인지 여부를 알 필요가 없다.

semWait와 semSignal 프리미티브는 원자적으로 수행된다. 각 프리미티브가 수행되면 완료될 때까지 중간에 다른 프로세스가 끼어들 수 없다.
세마포어는 유지할 수 있는 값의 범위에 따라 이진 세마포어와 범용 세마포어로 구분된다. 이진 세마포어는 범용 세마포어에 비해 구현하기 쉽다. 
또한 표현력에 있어서도 범용 세마포어와 동일한 능력을 갖는다. (비이진 세마포어를 **카운팅 세마포어**라 한다.)
이진 세마포어와 관련된 개념으로 **mutex**가 있는데 차이점은 세마포어의 경우 락을 설정한 프로세스와 해제하는 프로세스가 다를 수 있다.
하지만 mutex는 락을 설정한 프로세스와 해제하는 프로세스가 반드시 같아야 한다.

세마포어에서 블록된 프로세스들을 관리하기 위해 큐를 이용한다. 이때 큐에 연결된 프로세스들이 여러 개 있을 때 어떤 프로세스를 먼저 수행해야하는 지의 문제가 있다.
가장 공정한 정책은 선입선출인데 이를 이용하는 방식이 **강성 세마포어**이다. 반면 큐에서 제거되는 순서를 특별히 명시하지 않는 방식을 **약성 세마포어**라 한다.
강성 세마포어에서는 기아상태가 발생하지 않는데 약성 세마포어에서는 발생할 수 있따. 또한 강성 세마포어는 직관적이며 구현하기도 편리하고 실제로 많은 운영체제에서도 사용한다.

- **상호 배제**
프로세스가 공유 자원을 접근하려는 코드 부분이 임계영역으로 정의된다. 임계영역에 들어가기 직전에 semWait(s)를 호출한다. 만약 세마포어의 s 값이 양수가 아니라면, 프로세스는 블록된다.
만일 세마포어의 s 값이 1이라면, 1만큼 감소시킨 후 임계영역에 들어간다. 이제는 세마포어의 값이 양수가 아니며, 다른 프로세스들은 임계영역에 진입할 수 없다.
이런 방식으로 한 순간에 하나의 프로세스만 임계영역에 들어갈 수 있게 되며, 상호 배제가 보장된다.

- **생산자 소비자 문제**
데이터를 만드는 생산자 프로세스와 데이터를 소비하는 소비자 프로세스가 존재한다. 생산자는 하나 또는 그 이상의 데이터를 생성하고 버퍼에 저장한다.
소비자는 한 번에 하나씩 버퍼에서 데이터를 꺼내 소비한다. 이때 버퍼 접근이 중첩되어서는 안된다. 또한 버퍼가 가득차면 생산자는 더 이상 버퍼에 추가할 수 없으며,
버퍼가 비어 있으면 소비자도 꺼내 갈 수 없도록 제어해야 한다. 이런 버퍼 문제를 해결하는 간단한 방법은 상호 배제를 위해 semWait 함수와 semSignal 함수를 이용하는 것이다.

하지만 이 프로그램은 소비자가 버퍼의 데이터를 모두 소진하면 생산자의 생산이 있을 때까지 세마포어 delay에 대기해야하는 문제가 있다.
이 문제를 해결하기 위해 조건 문을 임계역역 내로 옮기는 것을 고려할 수 있지만 이는 교착 상태를 일으킬 수 있다.
또 다른 방법으로는 임계영역 내에 보조 변수를 사용하는 것인데 보다 깔끔한 방법은 범용 세마포어를 이용하는 것이다.

- 세마포어 구현
semWait와 semSignal 연산은 반드시 원자적으로 구현되어야 한다. 상호 배제를 보장하면서 이를 범용 세마포어로 구현하기 위한 방법으로 인터럽트 금지 등과 같은 하드웨어 지원을 사용하는 방법이다.
compare&swap 명령어를 이용하여 semWait와 semSignal 연산을 구현하였을 경우, 바쁜 대기 방식이지만 수행 시간이 비교적 짧기 때문에 길지 않게 대기할 수 있다.

```
const int sizeofbuffer = /* buffer size */;
semaphore s = 1, n = 0, e = sizeofbuffer;
void producer()
{
  while (true) {
    produce();
    semWait(e);
    semWait(s);
    append();
    semsignal(s);
    semSignal(n);
  }
}
void consumer() 
{ 
  while (true) {
    semWait(n);
    semWait(s);
    take();
    semSignal(s);
    semSignal(e);
    consume();
  }
}
void main()
{
  parbegin (producer, consumer);
}
```

### (4) 모니터
세마포어는 semWait와 semSignal 연산이 프로그램 전체에 산재해있고 이런 연산들이 전체적인 수행에 어떠한 영향을 미치는지 파악하기 어렵기 때문에 올바른 프로그램을 작성하기 어렵다. 이러한 어려움의 해결 방안으로 모니터가 제안되었다.
모니터는 프로그래밍 언어 수준에서 제공되는 구성체로 세마포어와 동일한 기능을 제공하며 보다 사용하기 쉽다.

- **시그널 기반 모니터**: 모니터는 지역 변수, 초기화 루틴, 프로시저로 구성된 소프트웨어 모듈이다. 모니터의 주된 특징은 다음과 같다.
  - 지역 변수는 모니터의 프로시저를 통해 접근 가능하다. (외부 접근 방지)
  - 프로세스는 모니터 프로시저 중에 하나를 호출 함으로써 모니터로 들어간다.
  - 한 순간에 오직 하나의 프로세스만이 모니터 내에 존재할 수 있다.

세 번쨰 특징을 지킴으로써 모니터는 상호 배제 기능을 제공한다. 다수의 프로세스들에 의해 공유되는 데이터는 모니터 내부에 위치시키면
상호 배제를 보장 받을 수 있다. 만일 모니터 내부의 데이터가 자원을 나타내면, 자원에 대한 상호 배제도 보장받을 수 있다.

모니터가 멀티프로세스의 병행 처리에 유용하게 이용될 수 있으려면 동기화 방법도 제공해야 한다.
모니터는 동기화를 위해 **조건 변수**를 제공한다. 조건 변수는 모니터 내부에 포함되며 모니터 내부에서만 접근할 수 있다.
조건 변수는 모니터에 사용하는 특수한 유형의 데이터 타입이며 다음 두 인터페이스에 의해서만 접근이 가능하다.
  - cwait(c): 호출한 프로세스를 조건 c에서 중지시킨다.
  - csignal(c): cwait(c)에 의해 중지되었던 프로세스의 수행을 재개시킨다.
*세마포어의 연산과는 다르게 모니터에서는 시그널이 발생하였을 때 그것을 기다리는 프로세스가 없다면 시그널이 없어지게 된다.*

모니터와 세마포어를 비교해보면 두 가지 기법은 책임의 소재에 차이가 있다. 모니터의 경우, 모니터 자체에서 상호 배제를 보장한다.
즉 생산자와 소비자가 동시에 버퍼에 접근할 수 없다. 따라서 개발자는 버퍼에 항목을 추가하거나 빈 항목을 삭제한느 것을 막기 위한 동기화
부분만 고려하면 된다. 세마포어의 경우 상호 배제와 동기화를 모두 프로그래머가 책임져야 한다.

또 다른 차이점으로는 모니터는 모든 동기화 함수가 모니터 내부에 국한되어 있다는 것이다. 따라서 동기화가 제대로 수행되었는지를 확인
하거나 오류를 발견하는 일이 쉬워진다. 또한 모니터가 올바르게 작성되면 보호된 자원을 접근하려는 프로세스의 수행은 올바르게 동작한다.
하지만 세마포어의 경우 그 자원을 사용하는 모든 프로세스들이 올바르게 프로그램 되어야만 그 자원에 대한 올바른 접근이 가능하다.

### (5) 메시지
프로세스들이 서로 상호작용할 때 만족되어야 할 두 가지 기본적인 요구사항은 동기화와 통신이다. 동기화는 상호 배제를 보장하기 위해
필요하며 통신은 프로세스들 간에 정보 교환을 위해 필요하다. 이 두가지 기능을 동시에 제공하는 대표적인 방법이 메시지 전달이다.
메시지 전달을 위한 가장 기본적인 프리미티브는 다음 두 가지이다.
  - send (destination, message)
  - receive (source, message)

프로세스를 전송하려는 정보를 메시지 형태로 만들어 목적 프로세스로 보낸다. 그리고 receive 프리미티브의 source는 보낸 프로세스르 가리킨다.

- **동기화**
메시지 송신자와 수신자의 상태는 블록킹 또는 비블록킹으로 구분할 수 있다. 송신과 수신이 어떤 유형을 사용하느냐에 따라 3가지 조합이 가능하다.
  - **블록킹 송신과 블록킹 수신**: 메시지가 전달될 때까지 송신자와 수신자 모두 대기한다. 이를 랑데부라고 부른다.
  - **비블록킹 송신과 블록킹 수신**: 메시지 송신자는 계속해서 수행할 수 있지만 수신자는 요청한 메시지가 도착할 때까지 대기한다.
  - **비블록킹 송신과 비블록킹 수신**: 송신자 수신자 모두 기다릴 필요 없다.

병행 처리 프로그래밍에서는 비블록킹 송신이 더 자연스럽다. 비블록킹 송신은 한 프로세스가 많은 메시지를 반복적으로 생성해서 보낼 수 있는 문제점이 있따. 많은 메시지의 전송을 제어할 수 있는 방법이 없으며 결국 시스템 자원의 낭비를 가져와 운영체제와 다른 프로세스의 성능 저하라는 피해를 준다. 또한 비블록킹 송신에서는 메시지의 전달 성공 여부의 확인을 프로그래머가 직접 담당해야 한다.

- **주소 지정**
send 프리미티브는 메시지 전달의 목적지를 명시할 수 있어야 하고 receive 프리미티브는 어떤 프로세스로부터 왔는지 명시할 수 있어야 한다. 프로세스를 명시하는 방법은 크게 직접 주소 지정과 간접 주소 지정으로 구분된다. **직접 주소 지정**은 프로세스의 식별자를 명시적으로 지정하는 것이다. **간접 주소 지정**은 잠시 메시지를 보관하는 공유 큐로 보낸다. 이러한 큐를 **메일박스**라고 한다. 두 프로세스가 통신할 때, 하나의 프로세스는 메일박스에 메시지를 보내고 다른 프로세스는 메일박스에서 메시지를 가져온다.

간접 주소 지정의 장점은 송신자와 수신자를 나눔으로써 메시지의 사용이 유연해진다라는 것이다. 송신자와 수신자의 관계는 일대일, 다대일, 일대다, 다대다 등으로 표현될 수 있다. **일대일** 관계는 두 프로세스만 연결되는 개인 통신로이다. 따라서 다른 프로세스의 방해를 받지 않는다. **다대일** 관계는 하나의 프로세스가 여러 프로세스에게 서비스를 제공하는 클라이언트/서버 모델에 적합하다. 이 경우 메일 박스는 포트라고 불린다. **일대다** 관계는 하나의 송신자와 다수의 수신자 관계이다. 방송 하는 경우에 유용하다. **다대다** 관계는 여러 개의 서버가 동시에 클라이언트에게 서비스를 제공할 때 사용된다.

- **판독자 기록자 문제**
판독자/기록자 문제는 다음과 같이 정의된다. 다수의  프로세스들이 공유하는 데이터 영역이 존재한다. 공유 데이터 영역은 파일일 수 있고 주기억장치의 특정 블록일 수도 있고 처리기의 레지스터일 수도 있다. 프로세스들은 공유 데이터를 읽김나하는 판독자와 쓰기만 하는 기록자로 구분된다. 판독자와 기록자 간에는 다음 조건이 만족되어야 한다.
  - 여러 판독자가 공유 데이터를 동시에 읽을 수 있다.
  - 한 순간에는 단 하나의 기록자만이 공유 데이터를 변경할 수 있다.
  - 기록자가 데이터를 변경하고 있는 동안에는 판독자가 그 파일을 읽을 수 없다.

따라서 판독자는 다른 판독자를 배제시키지 않고 작업을 수행할 수 있으나 기록자는 다른 기록자나 판독자를 모두 배제시키고 작업을 수행해야 한다.

### (6) 교착 상태
교착 상태는 프로세스가 통신이나 자원 경쟁 도중에 발생하는 무한대기 상태이다. 교착상태가 발생하면 연관된 프로세스들은 더 이상 진행하지 못 한다. 따라서 운영체제는 일부 프로세스를 종료시키거나 강제로 자원을 선점하는 등 교착상태를 해결하기 위한 작업을 수행해야 한다.

교착 상태를 해결하는 세 가지 일반적인 방법은 예방, 회피, 발견이다. 교착 상태 예방은 교착 상태 발생 가능성을 아예 없애는 것이다. 이것은 교착상태가 발생하기 위해 필요한 조건들 중에 하나를 시스템 설계할 때 제거하면 가능하다. 교착상태 발견은 자원이 요구될 때 가용하면 항상 할당해 주려는 운영체제에서 사용된다. 이 기법은 주기적으로 현재 시스템의 자원과 프로세스 관계를 분석하여 교착상태 발생 여부를 파악하고, 만일 발생했다면 이를 해결하는 방법이다. 교착 상태 회피는 자원을 할당할 때 이 할당이 교착상태를 야기할 가능성이 있는지 조사하고, 가능성이 없을 경우에만 할당해주는 방법이다.
