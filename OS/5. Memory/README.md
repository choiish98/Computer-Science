## 5. 메모리
시스템에서 주기억장치는 두 개의 부분으로 구분되는데 하나는 운영체제를 위한 공간이며 다른 하나는 수행 중인 프로그램을 위한 공간이다.
다수의 프로세스들을 수용하기 위해 프로그램을 위한 공간이 여러 개로 나뉘게 된다.
이와 같은 분할 작업은 운영체제에 의해서 동적으로 이루어지며 이를 **메모리 관리**라고 한다.

### (1) 메모리 관리 요구 조건
- **재배치**: 멀티프로그래밍 시스템에서 사용 가능한 주기억장치는 여러 프로세스에 의해 공유된다.
이때, 처리기의 효율을 극대화 하려는 목적으로 프로세스들은 주기억장치로 스왑인 또는 스왑아웃 되기도 한다.
프로세스들이 스왑아웃 후 다시 스왑인 됐을 때, 이전의 주기억장치의 동일한 위치로 적재되기는 어렵다.
대신 프로세스는 메모리의 다른 공간으로 **재배치**되어야 한다.

- **보호**: 프로세스는 다른 프로세스에 의한 원치 않는 간섭으로부터 보호되어야 한다.
재배치가 가능하게 되면 주기억장치 내의 프로그램 위치를 예측할 수 없다. 따라서 보호를 보장하기 위해 컴파일 시간에 확실한 주소를 알아내는 것을 불가능하다.
게다가 대부분의 프로그래밍 언어는 동적으로 주소를 계산하는 것을 허용한다.
따라서 모든 메모리 참조는 오직 그 프로세스에게 할당된 메모리 공간만을 참조한다는 것을 실행 시간에 검사받아야 한다.

  메모리 보호는 프로세서에 의해서 이루어져야 한다. 왜냐하면 운영체제는 프로그램이 만들어 내는 모든 메모리 참조를 예측할 수 없다.
그리고 사전에 발생 가능한 메모리 참조 침해 오류를 위해 모든 프로그램을 검사하는 일은 엄청난 시간을 소비하게 된다.
따라서 이를 검사하는 것은 메모리 참조 명령어의 실행 시에만 가능하다. 그래서 프로세서는 하드웨어적인 검사 기능을 가지고 있어야 한다.

- **공유**: 여러 개의 프로세스들이 동일한 프로그램을 수행하고 있다면, 각 프로세스들은 같은 데이터 구조를 접근하는 것이 필요하다.
따라서 메모리 관리 시스템은 필수적인 보호 기능을 침해하지 않는 범위에서 제한된 접근을 통하여 메모리의 일부분을 공유할 수 있도록 허용해야 한다.

- **논리적 구성**: 주기억장치는 일련의 바이트나 워드로 이루어진 선형의 또는 1차원의 주소 공간으로 이루어져 있다.
하지만 일반적인 프로그램은 구성이 모듈이라는 단위로 이루어져 있다.
운영체제와 하드웨어가 모듈로 이루어진 사용자 프로그램과 데이터를 효과적으로 처리할 수 있다면 다음과 같은 이점을 얻을 수 있다.
  + 각 모듈의 작성과 컴파일은 독립적으로 이루어질 수 있다.
  + 비교적 적은 추가 비용(오버헤드)으로 각 모듈마다 서로 다른 보호 등급(읽기전용, 수행전용)을 적용할 수 있다.
  + 프로세스들 간에 모듈을 공유할 수 있는 기법을 제공할 수 있다.
따라서 주기억장치의 주소를 논리적으로 프로그램의 모듈 단위로 구성할 수 있어야 한다.

- **물리적 구성**: 주기억장치는 현재 사용 중인 프로그램과 데이터를 저장하고 보조기억장치는 프로그램과 데이터를 장기간 저장하는데 사용한다.
이 두 계층 구조에서 주기억장치와 보조기억장치 사이의 정보 흐름을 어떻게 구성한는지는 시스템의 중요한 사항이다.
이 정보 흐름은 프로그래머 개인에게 전가하는 것은 다음과 같은 이유로 비현실적이고 바람직하지 못 하다.
  + 사용가능한 주기억장치의 용량이 프로그램과 데이터에 비해 부족할 수 있다. 이럴 경우 오버레이 기법을 사용해야 하는데 이는 프로그래머의 시간을 낭비하게 된다.
  + 멀티프로그래밍 환경에서 프로그래머는 사용가능한 공간의 양과 위치를 알 수 없다.
이와 같은 이유로 두 계층 사이의 정보 흐름은 시스템이 가져야 하는 책임이며 메모리 관리의 핵심 기능이다.


### (2) 메모리 분할
메모리 관리의 주된 작업은 처리기에 의해 실행될 프로세스를 보조기억장치로부터 주기억장치로 가져오는 것이다.
최근의 모든 멀티프로그래밍 시스템에서는 가상 메모리라고 알려진 정교한 기법을 사용한다. 이 가상 메모리는 세그멘테이션과 페이징이라는 기법을 기반으로 하고 있다.
따라서 가상 메모리를 고려하지 않는 상태에서 메모리의 분할 기법에 대해 알아보자.

- **고정 분할**: 대부분 메모리 관리 기법에서 운영체제는 주기억장치의 일부분만 차지하고 나머지 부분은 다수의 프로세스를 사용하기 위한 공간이다.
이 사용가능한 주기억장치를 관리하는 가장 단순한 기법은 고정된 경계를 가지는 메모리 영역으로 구분하는 것이다.
  - **분할 크기**: 우선 각 분할이 모두 같은 크기를 가지게 하는 균등 분할이 있을 수 있따. 균등 분할을 사용하면 다음과 같은 문제점이 있을 수 있다.
    - 프로그램이 파티션 보다 클 수 있다. 이런 경우 오버레이를 사용하여 프로그램이 필요한 부분만 주기억장치에 적재 한다. 이후 적재하지 않은 모듈이 필요할 때, 해당 프로그램의 파티션에
    어떤 프로그램이나 데이터가 있든 간에 덮어 써서 모듈을 적재 시킨다.
    - 주기억장치 이용이 매우 비효율적이다. 적재되는 데이터가 파티션보다 적을 때 파티션 내부 공간의 낭비가 발생하는 **내부 단편화**가 발생한다.
  비균등 분할을 사용하면 이 두 문제를 완전히 해결할 수는 없어도 영향을 줄이는 것이 가능하다.

    ![균등 분할과 비균등 분할](https://user-images.githubusercontent.com/56579239/156727350-94e13436-8f85-4685-b204-9b7df1b0af11.png)
  
  - **배치 알고리즘**: 균등 분할에서는 메모리 내의 프로세스 배치 과정은 간단하다. 사용 가능한 파티션이 존재한다면 프로세스는 해당 프로세스로 적재가 가능하다.
  왜냐하면 모든 파틴션들은 같은 크기이므로 어떤 파티션을 사용하던지 차이가 없다.
  
    ![고정 분할의 배치 알고리즘 큐](https://user-images.githubusercontent.com/56579239/156727371-30018459-be95-4cb7-bb3f-4157e349feef.png)
  
    비균등 분할에서는 파티션에 할당하기 위해 두 가지 방법이 가능하다. 간단한 방법으로는 각 프로세스의 용량에 맞는 가장 작은 파티션을 할당해주는 방법이다.
  이 경우 파티션에 할당될 프로세스들을 유지하는 스케줄링 큐가 필요하다. 이런 방식의 이점은 프로세스들이 항상 메모리 낭비를 최소화 하는 파티션에 적재된다는 것이다.
  하지만 메모리가 적은 프로세스만 존재하여 큰 메모리가 필요한 큐에 프로세스가 적재되지 않아 메모리가 낭비될 수 있다.
  
    따라서 하나의 큐로 모든 프로세스를 처리하는 방법이 더 자주 사용된다. 이 방법은 프로세스를 적재할 시점에 사용 가능한 파티션 중 프로세스를 적재할 수 있는 가장 작은 크기의 파티션이 선택된다.
  이 방법을 사용하면 어느정도 융퉁성을 가지게 된다. 게다가 비교적 간단하고 운영체제 소프트웨어의 기능을 최소로하고 오버헤드 역시 절감 된다.
  하지만 다음과 같은 단점을 지닌다.
    - 시스템 생성 시간에 미리 정해진 파티션 수에 의해 시스템 내에서 활성화 된 프로세스들의 개수가 제한을 받는다.
    - 시스템 생성 시간에 파티션 사이즈가 미리 정해지기 때문에 작은 작업들의 경우 파티션 공간을 효율적으로 활용할 수 없다.
  이와 같은 이유로 현재는 고정 분할을 채택한 운영체제는 거의 알려져 있지 않다.

- **동적 분할**: 동적 분할에서 파티션의 크기와 개수는 가변적이다. 한 프로세스가 주기억장치로 적재될 때 정확히 요구된 크기만큼의 메모리만 할당받는다.
처음에는 운영체제만이 주기억장치에 적재되어 있다. 그리고 차례로 운영체제가 끝나는 곳으로부터 프로세스가 적재되기 시작한다.
이 결과, 메모리의 끝에 다른 프로세스를 배정하기에는 너무 작은 메모리가 마치 "구멍"처럼 남게 된다.
다음 프로세스를 적재하기 위해, 다른 프로세스를 스왑아웃한 후 다른 프로세스를 적재해도 남는 공간 만큼 구멍이 생기게 된다.
이와 같이 모든 파티션 영역 이외의 메모리가 점차 사용할 수 없는 조각으로 변하는 현상을 **외부 단편화**라고 한다.

  ![동적 분할의 예](https://user-images.githubusercontent.com/56579239/156727415-06f88a91-30a9-4585-a8e9-d0d4b48bbf6e.png)

  외부 단편화를 극복하는 방법으로 **메모리 집약**이 있다. 운영체제는 프로세스가 사용하는 파티션을 이동시켜 각 파티션이 연속적이 되도록 만들고 메모리의 모든 빈 공간이 하나의 블록이 되도록 한다.
하지만 메모리 집약은 시간이 많이 걸리며 처리기 시간을 낭비하는 단점이 있다.
또, 동적 재배치 기능이 필요해진다. 프로그램의 메모리 참조가 아무런 영향을 받지 않고 프로그램을 주기억장치 내에서 이동시킬 수 있어야 한다.

  - **배치 알고리즘**: 메모리 집약은 많은 시간이 소모되는 작업이기 때문에 운영체제는 프로세스에게 메모리를 할당하는 방법을 현명하게 결정해야 한다.
  이러한 배치 알고리즘에는 세 가지가 있다.
    - **최적 적합**: 요청된 크기와 가장 근접한 크기의 메모리를 선택한다.
    - **최초 적합**: 메모리의 처음부터 검사해서 크기가 충분한 첫 번째 메모리 블록을 선택한다.
    - **순환 적합**: 가장 최근에 배치되었던 메모리의 위치에서부터 검사를 시작해 크기가 충분한 메모리 블록을 선택한다.
    
    ![메모리 구성의 예](https://user-images.githubusercontent.com/56579239/156727443-205abe52-057a-4d84-8f7b-0b6fe611969d.png)
    
    이 방법들 중에서 어느 것이 가장 적합한 지는 스와핑의 실제 순서와 해당 프로세스들의 크기에 의존적이다. 하지만 일반적인 분석은 가능하다.
  최초적합 알고리즘은 가장 간단할 뿐만 아니라 대부분의 경우 최적이며 가장 빠르다. 순환적합 알고리즘은 최초적합보다는 약간 더 나쁜 결과를 내는 경향이 있다.
  최초적합 알고리즘은 메모리의 앞부분에 여러 개의 자유 메모리들을 만들어내는데 최초적합 조사를 할 때마다 매번 검사되어야 한다.
  최적적합은 가장 작은 블록을 찾아 배정하기 때문에 가장 작은 단편들을 만들게 된다. 각 메모리 요구 시에 가장 작은 메모리를 낭비하지만 다른 메모리 할당 요구를 만족시키기에는
  너무 작은 블록들을 주기억장치 전체에 여기저기 만들게 된다. 따라서 최적적합은 가장 성능이 나쁜 방법이다.
  
- **재배치**: 고정 분할 기법을 사용할 경우, 특정 프로세스는 항상 같은 파티션에 할당될 것이라는 예상을 할 수 있다. 따라서 가장 간단한 재배치 로더가 사용될 수 있다.
처음 적재되어질 때 코드 안에 있던 메모리 참조를 위한 상대적인 주소들은 적재된 프로세스의 시작 주소를 기준으로 결정되는 주기억장치 내의 절대 주소로 바뀌게 된다.

  균등 분할인 경우나 단일 큐를 쓰는 비균등 분할인 경우, 동적 분할의 경우는 프로세스는 생존 기간 동안 다른 파티션에 적재될 수 있다. 
게다가 메모리 집약 작업을 할 경우 프로세스들은 옮겨지게 된다. 그러므로 참조된 위치는 고정되지 않는다.
이러한 문제를 해결하기 위해 프로세스의 주소를 몇 가지 유형으로 구분한다.
  - **논리주소**: 현재 데이터가 적재된 메모리와는 독립적인 메모리 위치에 대한 참조이다.
  - **상대주소**: 어떤 알려진 지점으로부터 상대적인 위치를 의미하는 주소이다.
  - **절대주소**: 주기억장치 안에서의 실제 위치를 말한다.
  
  ![재배치의 예](https://user-images.githubusercontent.com/56579239/156727497-a7f2df13-3593-4e7e-8e7a-78e7140ff676.png)
  
  위와 같 기법을 이용하여 수행 중인 프로그램이 스왑인과 스왑아웃 되도록 한다. 이 기법은 프로세스 보호 기능도 동시에 수행한다.
  각 프로세스는 베이스 레지스터와 경계 레지스터에 의해 격리되므로 다른 프로세스의 원하지 않는 접근으로부터 안전하게 보호된다.
  
  
### (3) 페이징
주기억장치를 비교적 작은 곶어 사이트 파티션으로 나누고 각 프로세스 또한 같은 크기의 고정 조각으로 나눈다고 가정해보자.
**페이지**라 불리는 이 프로세스 조각은 **프레임**이라고 알려진 빈 메모리의 조각에 저장될 수 있다.
이 기법에서는 외부 단편화로 인한 메모리 낭비는 없고 내부 단편화로 인한 낭비만이 존재하는데 그것도 각 프로세스의 마지막 페이지에서만 존재한다.

![페이징 예](https://user-images.githubusercontent.com/56579239/156727528-3596ec3b-81c8-4d1c-aca9-fa200fcc3f4f.png)

지금 이 예와 같이 프로세스를 적재할 연속된 프레임이 없어도 눈리주소 개념을 이용하여 프로세스를 적재할 수 있다.
이에 따라 단순히 베이스 주소 레지스터 하나만으로 프로세스의 주소를 충분히 저장할 수 없다. 그래서 운영체제는 각 프로세스마다 하나의 **페이지 테이블**을 유지한다.
페이지 테이블은 프로세스의 각 페이지들에 해당하는 프레임의 위치를 관리한다. 프로그램 안에서 각 논리주소는 페이지 번호와 페이지 내의 오프셋으로 구성된다.

단순 페이징은 고정 분할 방법과 유사하다. 페이징의 다른 점은 파티션의 크기가 보다 작고 한 프로그램이 하나 이상의 파티션을 차지할 수 있으며, 이 파티션이 연속적일 필요는 없다는 점이다.
이 페이징 기법이 편리하게 사용되려면, 페이지 크기와 프레임의 크기를 2의 거듭 제곱이 되도록 해야 한다.
페이지의 크기를 2의 거듭 제곱이 되도록 하면, 프로그램의 시작 위치로부터의 상대 주소와 페이지 번호와 오프셋으로 표현되는 논리 주소가 같아지기 때문이다.

페이지의 크기를 2의 거듭 제곱으로 사용하는 데에는 2가지의 중요한 장점이 있다.
  - 논리 주소의 구조가 프로그래머, 어셈블러, 링커에게 투명하다.
  - 수행 중에 동적 주소 변환을 담당할 하드웨어 기능을 구현하기가 비교적 쉽다.
  

### (4) 세그멘테이션
세그멘테이션 기법에서는 프로그램과 그와 관련된 데이터들이 여러 개의 **세그먼트**로 나누어진다. 세그먼트는 최대 길이에는 제한이 있더라도 프로그램의 모든 세그먼트가 같은 크기일 필요는 없다.
비균등 크기의 세그먼트를 사용하기 때문에 동적 분할과 유사하다. 차이점은 세그멘테이션의 경우 프로그램이 하나 이상의 파티션을 차지할 수 있고 이 파티션들이 연속적일 필요는 없다는 것이다.
세그멘테이션은 내부단편화는 발생시키지 않지만 외부단편화를 초래한다. 하지만 프로세스가 보다 작은 크기로 나누어지기 때문에 외부단편화는 상대적으로 적은 편이다.

페이징이 프로그래머에게 투명한 것에 비해 세그먼테이션은 보통 프로그래머가 각 세그먼트를 지정할 수 있으며 프로그램과 데이터를 편의대로 나누기 위한 수단으로 제공된다.
구조적 프로그래밍을 위하여 프로그램 또는 데이터는 더 세분화된 여러 세그먼트로 나뉠 수 있다. 세그먼트 기법의 가장 불편한 점은 프로그래머가 세그먼트의 최대 크기를 알고 있어야 한다는 것이다.
비균등 세그먼트의 또 다른 단점은 논리주소와 물리주소 간에 복잡한 관계가 존재한다는 것이다. 각 프로세스마다 세그먼트 테이블을 이용하고 주기억장치의 사용 가능한 블록들의 리스트를 유지한다.
세그먼트 테이브의 각 항목은 대응되는 세그먼트의 주기억장치 내에 시작 주소를 가지고 있어야 한다. 유효한 주소들만 접근될 수 있도록 해당 세그먼트의 길이를 제공해야 한다.
 
 
 
